<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trình Soạn Thảo Bộ Từ Vựng Chuyên Nghiệp</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Thư viện docx.js để xuất file Word -->
    <script type="module">
        import * as docx from 'https://cdn.jsdelivr.net/npm/docx@8.5.0/+esm';
        window.docx = docx; // Gán vào window để truy cập global
    </script>
    <style>
        :root {
            --blur-intensity: 12px; --saturation-intensity: 150%; --glass-bg-color: rgba(255, 255, 255, 0.45);
            --glass-border-color: rgba(255, 255, 255, 0.6); --shadow-color: rgba(67, 56, 202, 0.15);
            --primary-accent: #6d28d9; --text-primary: #0f172a; --text-secondary: #475569;
            --app-bg-start: #f5f7ff; --app-bg-end: #e0e7ff;
        }
        body.dark {
            --glass-bg-color: rgba(29, 39, 58, 0.45); --glass-border-color: rgba(255, 255, 255, 0.2);
            --shadow-color: rgba(0, 0, 0, 0.25); --primary-accent: #a78bfa; --text-primary: #f1f5f9;
            --text-secondary: #94a3b8; --app-bg-start: #0f172a; --app-bg-end: #1e293b;
        }
        body { font-family: 'Be Vietnam Pro', sans-serif; background-color: var(--app-bg-start); background-image: linear-gradient(135deg, var(--app-bg-start) 0%, var(--app-bg-end) 100%); color: var(--text-primary); transition: background-color 0.3s, color 0.3s; }
        body.dark h1, body.dark h2, body.dark h3, body.dark label, body.dark p, body.dark input, body.dark textarea, body.dark select, body.dark summary, body.dark th, body.dark button, body.dark .tab { color: var(--text-primary); }
        body.dark .text-gray-700 { color: var(--text-primary) !important; }
        body.dark #dark-mode-label .fa-moon { color: var(--primary-accent); } #dark-mode-label .fa-sun { color: #f59e0b; }
        .background-shapes { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none; }
        .shape { position: absolute; border-radius: 50%; filter: blur(25px); opacity: 0.6; animation: float 30s infinite alternate ease-in-out; }
        .shape1 { width: 250px; height: 250px; background: linear-gradient(135deg, #8b5cf6, #3b82f6); top: 10%; left: 5%; }
        .shape2 { width: 180px; height: 180px; background: linear-gradient(135deg, #14b8a6, #67e8f9); bottom: 15%; right: 10%; animation-duration: 35s; }
        @keyframes float { from { transform: translateY(20px) scale(1); } to { transform: translateY(-20px) scale(1.05); } }
        .glass-panel { background: var(--glass-bg-color); backdrop-filter: blur(var(--blur-intensity)) saturate(var(--saturation-intensity)); border-radius: 24px; border: 1px solid var(--glass-border-color); box-shadow: 0 8px 32px 0 var(--shadow-color); transition: background 0.3s, border 0.3s; }
        .btn { padding: 12px 24px; border-radius: 12px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; display: inline-flex; align-items: center; justify-content: center; gap: 8px; user-select: none; }
        .btn:disabled { cursor: not-allowed; opacity: 0.6; transform: none !important; }
        .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .btn-primary { background: var(--primary-accent); color: white; }
        .btn-secondary { background: rgba(255, 255, 255, 0.4); color: var(--text-primary); border: 1px solid rgba(255, 255, 255, 0.6); }
        body.dark .btn-secondary { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.2); }
        .btn-danger { background: #ef4444; color: white; }
        .input-field { background: rgba(255, 255, 255, 0.4); border: 1px solid rgba(255, 255, 255, 0.5); width: 100%; padding: 12px; border-radius: 12px; transition: background 0.3s, border 0.3s; }
        .input-field:focus { outline: none; box-shadow: 0 0 0 2px var(--primary-accent); }
        body.dark .input-field { background: rgba(0,0,0,0.2); border-color: rgba(255,255,255,0.2); }
        .input-field:disabled { background-color: rgba(229, 231, 235, 0.5); cursor: not-allowed; }
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.2); backdrop-filter: blur(8px); align-items: center; justify-content: center; animation: fadeIn 0.3s ease; }
        .modal.is-open { display: flex; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .loader { width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid var(--primary-accent); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #data-table th { position: sticky; top: 0; background-color: rgba(255,255,255,0.6); backdrop-filter: blur(5px); z-index: 10; }
        body.dark #data-table th { background-color: rgba(29, 39, 58, 0.6); }
        [contenteditable]:focus { outline: 2px solid var(--primary-accent); background-color: rgba(255, 255, 255, 0.7); border-radius: 4px; }
        body.dark [contenteditable]:focus { background-color: rgba(0, 0, 0, 0.3); }
        .task-details { border-left: 2px solid var(--primary-accent); padding-left: 12px; margin-top: 8px; }
        .task-summary { font-weight: 700; cursor: pointer; list-style: none; }
        .task-summary::-webkit-details-marker { display: none; }
        .task-content { font-size: 12px; margin-top: 8px; color: var(--text-secondary); }
        .task-content .sentence, .task-content .option { background: rgba(0,0,0,0.05); padding: 4px 8px; border-radius: 6px; margin: 4px 0; color: var(--text-primary); }
        body.dark .task-content .sentence, body.dark .task-content .option { background: rgba(255,255,255,0.08); }
        .correct-answer { border-left: 3px solid #22c55e; }
        .tab-container { display: flex; border-bottom: 2px solid var(--glass-border-color); margin-bottom: 1.5rem; }
        .tab { padding: 0.75rem 1.5rem; cursor: pointer; font-weight: 600; position: relative; transition: color 0.3s; }
        .tab.active { color: var(--primary-accent); }
        .tab.active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 2px; background-color: var(--primary-accent); }
        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.5s; }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="background-shapes"><div class="shape shape1"></div><div class="shape shape2"></div></div>

    <!-- Login Screen -->
    <div id="login-screen" class="modal is-open">
        <div class="glass-panel p-8 rounded-2xl shadow-xl text-center w-full max-w-sm">
            <h2 class="text-2xl font-bold mb-6">Đăng nhập</h2>
            <div class="space-y-4 text-left">
                <div><label for="email-input" class="block text-sm font-medium mb-1">Email</label><input type="email" id="email-input" class="input-field"></div>
                <div><label for="password-input" class="block text-sm font-medium mb-1">Mật khẩu</label><input type="password" id="password-input" class="input-field"></div>
            </div>
            <button id="login-btn" class="btn btn-primary w-full mt-6">Đăng nhập</button>
            <p id="login-error" class="text-red-500 mt-2 h-5"></p>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-content" class="max-w-screen-2xl mx-auto" style="display: none;">
        <header class="flex justify-between items-center mb-8">
            <h1 id="page-title" class="text-4xl font-bold">Trình Soạn Thảo Bộ Từ Vựng</h1>
            <div class="flex items-center gap-4">
                <label id="dark-mode-label" class="flex items-center cursor-pointer text-slate-500">
                    <i class="fas fa-moon mr-2"></i>
                    <div class="relative">
                        <input type="checkbox" id="dark-mode-toggle" class="sr-only">
                        <div class="block bg-gray-600 w-14 h-8 rounded-full"></div>
                        <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition"></div>
                    </div>
                    <i class="fas fa-sun ml-2"></i>
                </label>
                <button id="logout-btn" class="btn btn-danger">Đăng xuất</button>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            <!-- Left Panel: Controls -->
            <aside class="lg:col-span-2 space-y-8">
                <div class="glass-panel p-6">
                    <h2 class="text-2xl font-bold mb-4">1. Thông tin chung</h2>
                    <div class="space-y-4">
                        <div><label for="test-id" class="block text-sm font-medium">Mã định danh (ID)</label><input type="text" id="test-id" class="input-field" placeholder="vd: unit_1_family"></div>
                        <div><label for="test-title" class="block text-sm font-medium">Tiêu đề bộ từ vựng</label><input type="text" id="test-title" class="input-field" placeholder="vd: Unit 1: Family Life"></div>
                    </div>
                </div>
                 <div class="glass-panel p-6">
                    <h2 class="text-2xl font-bold mb-4">2. Nhập liệu & Cài đặt</h2>
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                         <div>
                             <label class="block text-sm font-medium mb-1">File Từ vựng (.csv)</label>
                             <label for="vocab-csv-upload" class="btn btn-secondary w-full"><i class="fas fa-upload mr-2"></i>Tải lên</label>
                             <input type="file" id="vocab-csv-upload" class="hidden" accept=".csv">
                             <p id="vocab-file-name" class="mt-2 text-sm text-center truncate"></p>
                         </div>
                         <div>
                             <label class="block text-sm font-medium mb-1">File Cấu trúc (.csv)</label>
                             <label for="structures-csv-upload" class="btn btn-secondary w-full"><i class="fas fa-upload mr-2"></i>Tải lên</label>
                             <input type="file" id="structures-csv-upload" class="hidden" accept=".csv">
                             <p id="structures-file-name" class="mt-2 text-sm text-center truncate"></p>
                         </div>
                     </div>
                    <div class="mt-6">
                        <label for="cefr-level-slider" class="block text-sm font-medium mb-1">Trình độ (CEFR)</label>
                        <input type="range" id="cefr-level-slider" min="0" max="100" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                        <div class="flex justify-between text-xs mt-1"><span>A1</span><span>A2</span><span>B1</span><span>B2</span><span>C1</span><span>C2</span></div>
                        <p id="cefr-level-display" class="text-center font-semibold mt-2"></p>
                    </div>
                    <div class="text-center mt-6"><button id="process-files-btn" class="btn btn-primary">Xử lý Dữ liệu</button></div>
                </div>
                 <div class="glass-panel p-6">
                    <h2 class="text-2xl font-bold mb-4">3. Cấu hình AI</h2>
                    <div class="space-y-4">
                        <div><label for="gemini-api-key" class="block text-sm font-medium">Google Gemini API Key</label><input type="password" id="gemini-api-key" class="input-field" placeholder="Dán API Key của bạn..."></div>
                        <div>
                            <label for="ai-model-select" class="block text-sm font-medium mb-1">Mô hình Gemini</label>
                            <select id="ai-model-select" class="input-field w-full">
                                <option value="gemini-1.5-flash-latest">Gemini 1.5 Flash (Nhanh & Tiết kiệm)</option>
                                <option value="gemini-1.5-pro-latest">Gemini 1.5 Pro (Chất lượng cao)</option>
                            </select>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Right Panel: Data and Actions -->
            <main class="lg:col-span-3 space-y-8">
                <div id="data-review-section" class="glass-panel p-6 hidden">
                     <h2 class="text-2xl font-bold mb-4">4. Dữ liệu Khảo thí</h2>
                    <div id="table-container" class="max-h-[80vh] overflow-auto rounded-lg border border-white/50">
                        <table id="data-table" class="w-full text-sm">
                            <thead>
                                <tr class="text-left">
                                    <th class="p-3 w-8"><input type="checkbox" id="select-all-checkbox"></th>
                                    <th class="p-3 w-1/4">Từ vựng & Cấu trúc</th>
                                    <th class="p-3 w-3/4">Các Gói Bài Tập</th>
                                    <th class="p-3 text-center">AI</th>
                                </tr>
                            </thead>
                            <tbody id="data-table-body"></tbody>
                        </table>
                    </div>
                    <div class="mt-6 text-center flex flex-wrap justify-center gap-4">
                        <button id="fetch-audio-btn" class="btn btn-secondary"><i class="fas fa-volume-up mr-2"></i>Tìm Audio</button>
                        <button id="enrich-data-btn" class="btn btn-secondary"><i class="fas fa-wand-magic-sparkles mr-2"></i>Làm giàu Dữ liệu</button>
                        <button id="export-word-btn" class="btn btn-secondary"><i class="fas fa-file-word mr-2"></i>Xuất ra Word</button>
                    </div>
                </div>
                <div class="text-center"><button id="upload-btn" class="btn btn-primary text-lg w-full"><i class="fas fa-cloud-upload-alt mr-2"></i>Lưu Bộ Từ Vựng</button><p id="upload-log" class="font-semibold mt-2 h-5"></p></div>
            </main>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="modal-container"></div>
    <div id="manual-prompt-modal" class="modal">
        <div class="glass-panel p-8 w-full max-w-4xl max-h-[90vh] flex flex-col">
            <h2 class="text-2xl font-bold mb-4">Làm giàu dữ liệu thủ công</h2>
            <div class="flex-grow grid grid-cols-1 md:grid-cols-2 gap-6 overflow-hidden">
                <div class="flex flex-col h-full">
                    <label class="font-medium mb-2">Bước 1: Sao chép Prompt này</label>
                    <textarea id="manual-prompt-output" readonly class="input-field flex-grow font-mono text-xs"></textarea>
                    <button id="copy-prompt-btn" class="btn btn-primary mt-2">Sao chép Prompt</button>
                </div>
                <div class="flex flex-col h-full">
                    <label class="font-medium mb-2">Bước 2: Dán kết quả JSON từ Gemini vào đây</label>
                    <textarea id="manual-prompt-input" class="input-field flex-grow font-mono text-xs" placeholder="Dán kết quả JSON tại đây..."></textarea>
                    <button id="process-manual-result-btn" class="btn btn-primary mt-2">Cập nhật dữ liệu</button>
                </div>
            </div>
            <button id="close-manual-modal-btn" class="btn btn-danger mt-6 mx-auto">Đóng</button>
        </div>
    </div>

    <!-- Word Export Modal -->
    <div id="word-export-modal" class="modal">
        <div class="glass-panel p-6 sm:p-8 w-full max-w-4xl max-h-[95vh] flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold">Tùy chọn Xuất Word</h2>
                <button id="close-word-export-modal-btn" class="text-2xl hover:text-red-500 transition-colors">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="tab-container">
                <div class="tab active" data-tab="random-test-tab">Tạo Đề Thi Ngẫu Nhiên</div>
                <div class="tab" data-tab="full-export-tab">Xuất Toàn Bộ Câu Hỏi</div>
            </div>

            <!-- Tab Content -->
            <div class="flex-grow overflow-y-auto pr-2">
                <!-- Tab 1: Random Test Generator -->
                <div id="random-test-tab" class="tab-content active">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                        <div>
                            <h3 class="font-bold mb-2">Thông tin Chung</h3>
                            <div class="space-y-4">
                                <div><label for="export-main-title" class="block text-sm font-medium">Tiêu đề chính</label><input type="text" id="export-main-title" class="input-field" value="ĐỀ THI CUỐI KỲ"></div>
                                <div><label for="export-subtitle" class="block text-sm font-medium">Phụ đề (vd: Thời gian)</label><input type="text" id="export-subtitle" class="input-field" value="Thời gian làm bài: 90 phút"></div>
                                <div><label for="export-test-code-base" class="block text-sm font-medium">Mã đề gốc</label><input type="text" id="export-test-code-base" class="input-field" value="10"></div>
                            </div>
                        </div>
                        <div>
                            <h3 class="font-bold mb-2">Số lượng & Chiến lược</h3>
                            <div class="space-y-4">
                                <div><label for="export-total-questions" class="block text-sm font-medium">Tổng số câu hỏi mỗi đề</label><input type="number" id="export-total-questions" class="input-field" value="20"></div>
                                <div><label for="export-num-versions" class="block text-sm font-medium">Số lượng mã đề</label><input type="number" id="export-num-versions" class="input-field" value="2"></div>
                                <div>
                                    <label class="block text-sm font-medium">Tùy chọn</label>
                                    <div class="mt-2 space-y-2">
                                        <div class="flex items-center"><input type="radio" id="strategy-shuffle" name="strategy" value="shuffle" checked class="mr-2"><label for="strategy-shuffle">Trộn lại câu hỏi (hoán vị)</label></div>
                                        <div class="flex items-center"><input type="radio" id="strategy-new" name="strategy" value="new" class="mr-2"><label for="strategy-new">Tạo bộ câu hỏi mới</label></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="md:col-span-2">
                            <h3 class="font-bold mb-2">Chọn Level và Tỷ lệ câu hỏi:</h3>
                            <div id="export-levels-container" class="grid grid-cols-1 sm:grid-cols-2 gap-x-8"></div>
                            <div class="mt-2 font-bold">Tổng: <span id="export-total-percentage">0</span>%</div>
                            <div id="export-validation-message" class="text-red-500 font-semibold h-6 mt-1"></div>
                        </div>
                    </div>
                    <div class="text-center mt-6">
                        <button id="generate-random-test-btn" class="btn btn-primary">Tạo & Tải xuống Bộ đề thi</button>
                    </div>
                </div>

                <!-- Tab 2: Full Bank Exporter -->
                <div id="full-export-tab" class="tab-content">
                    <h3 class="text-xl font-semibold mb-4">Xuất toàn bộ ngân hàng câu hỏi</h3>
                    <p class="text-secondary mb-6">Chức năng này sẽ xuất TẤT CẢ các câu hỏi đã được AI tạo ra từ bộ từ vựng hiện tại. Lý tưởng để tạo tài liệu ôn tập hoặc lưu trữ.</p>
                    <div>
                        <label class="block text-lg font-medium mb-2">Sắp xếp tài liệu theo:</label>
                        <div class="mt-2 space-y-3">
                            <div class="flex items-center glass-panel p-4 rounded-lg"><input type="radio" id="sort-by-word" name="sort-order" value="word" checked class="w-5 h-5 mr-3"><label for="sort-by-word" class="w-full"><strong>Theo Từ vựng:</strong> Nhóm tất cả các câu hỏi theo từng từ.</label></div>
                            <div class="flex items-center glass-panel p-4 rounded-lg"><input type="radio" id="sort-by-level" name="sort-order" value="level" class="w-5 h-5 mr-3"><label for="sort-by-level" class="w-full"><strong>Theo Level:</strong> Nhóm tất cả các câu hỏi theo 4 cấp độ tư duy.</label></div>
                        </div>
                    </div>
                     <div class="text-center mt-8">
                        <button id="generate-full-export-btn" class="btn btn-primary">Tạo & Tải xuống Tài liệu</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getFirestore, doc, setDoc, getDoc, serverTimestamp, writeBatch, collection, getDocs } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";
        import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js";

        // --- CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyBUet6ZsBTwJG_gTKM2bGFG1AKD3t0hV20",
            authDomain: "b1-baotram.firebaseapp.com",
            projectId: "b1-baotram",
            storageBucket: "b1-baotram.appspot.com",
            messagingSenderId: "948701163187",
            appId: "1:948701163187:web:043f2d381d63e741114ac6",
            measurementId: "G-33NHT07JHE"
        };
        const CLOUD_FUNCTION_URL = "https://getoaldaudio-asjwauz37q-uc.a.run.app";
        const AI_BATCH_SIZE = 5;
        const ALL_TASK_TYPES = {
            // Level 1: Nền tảng
            meaning_mcq: { level: 1, title: "Meaning MCQ" },
            ipa_fill: { level: 1, title: "IPA Fill" },
            basic_example: { level: 1, title: "Basic Example" },
            // listening_typing: { level: 1, title: "Listening & Typing" }, // Future task
            
            // Level 2: Ngữ pháp & Cấu trúc
            word_family_mcq: { level: 2, title: "Word Family" },
            sentence_unscramble: { level: 2, title: "Sentence Unscramble" },
            error_correction: { level: 2, title: "Error Correction" },
            tripled_sentence: { level: 2, title: "Tripled Sentence" },
            
            // Level 3: Ngữ nghĩa & Ngữ dụng
            best_fit_replacement: { level: 3, title: "Best-fit Replacement" },
            best_paraphrase: { level: 3, title: "Best Paraphrase" },
            antonym_mcq: { level: 3, title: "Antonym Challenge" },
            collocation_odd_one_out: { level: 3, title: "Collocation Odd One Out" },

            // Level 4: Tư duy Phản biện
            inference_from_scenario: { level: 4, title: "Inference from Scenario" },
            main_idea: { level: 4, title: "Find the Main Idea" },
            paragraph_completion: { level: 4, title: "Find the Conclusion" },
            argument_strengthening: { level: 4, title: "Strengthen the Argument" },
            argument_weakening: { level: 4, title: "Weaken the Argument" },
            tone_purpose_analysis: { level: 4, title: "Tone/Purpose Identification" },
            sentence_role_analysis: { level: 4, title: "Sentence Role Analysis" },
        };
        const LEVEL_DEFINITIONS = {
            1: "Level 1: Nền tảng",
            2: "Level 2: Ngữ pháp & Cấu trúc",
            3: "Level 3: Ngữ nghĩa & Ngữ dụng",
            4: "Level 4: Tư duy Phản biện"
        };


        // --- INITIALIZATION ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        let localWordList = [], vocabCsvText = '', structuresCsvText = '';

        // --- DOCX.JS DESTRUCTURING ---
        const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, Table, TableCell, TableRow, WidthType, BorderStyle, PageBreak, Footer, PageNumber, SectionType } = window.docx;

        // --- DOM ELEMENTS ---
        const DOM = {
            loginScreen: document.getElementById('login-screen'), mainContent: document.getElementById('main-content'),
            loginBtn: document.getElementById('login-btn'), logoutBtn: document.getElementById('logout-btn'),
            emailInput: document.getElementById('email-input'), passwordInput: document.getElementById('password-input'),
            loginError: document.getElementById('login-error'), testIdInput: document.getElementById('test-id'),
            testTitleInput: document.getElementById('test-title'), dataReviewSection: document.getElementById('data-review-section'),
            dataTableBody: document.getElementById('data-table-body'), fetchAudioBtn: document.getElementById('fetch-audio-btn'),
            enrichDataBtn: document.getElementById('enrich-data-btn'),
            uploadBtn: document.getElementById('upload-btn'), uploadLog: document.getElementById('upload-log'),
            modalContainer: document.getElementById('modal-container'), 
            vocabCsvUploadInput: document.getElementById('vocab-csv-upload'), vocabFileNameDisplay: document.getElementById('vocab-file-name'),
            structuresCsvUploadInput: document.getElementById('structures-csv-upload'), structuresFileNameDisplay: document.getElementById('structures-file-name'),
            processFilesBtn: document.getElementById('process-files-btn'), darkModeToggle: document.getElementById('dark-mode-toggle'),
            cefrSlider: document.getElementById('cefr-level-slider'), cefrDisplay: document.getElementById('cefr-level-display'),
            geminiApiKeyInput: document.getElementById('gemini-api-key'), aiModelSelect: document.getElementById('ai-model-select'),
            manualPromptModal: document.getElementById('manual-prompt-modal'), manualPromptOutput: document.getElementById('manual-prompt-output'),
            manualPromptInput: document.getElementById('manual-prompt-input'), copyPromptBtn: document.getElementById('copy-prompt-btn'),
            processManualResultBtn: document.getElementById('process-manual-result-btn'), closeManualModalBtn: document.getElementById('close-manual-modal-btn'),
            pageTitle: document.getElementById('page-title'),
            exportWordBtn: document.getElementById('export-word-btn'),
            selectAllCheckbox: document.getElementById('select-all-checkbox'),
            // Word Export Modal Elements
            wordExportModal: document.getElementById('word-export-modal'),
            closeWordExportModalBtn: document.getElementById('close-word-export-modal-btn'),
            exportValidationMessage: document.getElementById('export-validation-message'),
            exportLevelsContainer: document.getElementById('export-levels-container'),
            exportTotalPercentage: document.getElementById('export-total-percentage'),
            generateRandomTestBtn: document.getElementById('generate-random-test-btn'),
            generateFullExportBtn: document.getElementById('generate-full-export-btn'),
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
        };

        // --- UI & HELPERS ---
        function showAlert(message, type = 'info', details = '') {
            const colors = { info: 'blue', success: 'green', error: 'red' };
            const colorClass = `bg-${colors[type]}-500`;
            const detailsHTML = details ? `<pre class="mt-4 p-2 bg-gray-100 dark:bg-gray-800 text-left text-xs rounded-md max-h-40 overflow-auto">${details}</pre>` : '';
            
            const modal = document.createElement('div');
            modal.className = 'modal is-open';
            modal.innerHTML = `<div class="modal-content glass-panel text-center p-8 rounded-lg max-w-lg w-full">
                <p class="text-lg mb-6">${message}</p>
                ${detailsHTML}
                <button class="btn ${colorClass} text-white mt-4">OK</button>
            </div>`;
            
            modal.querySelector('button').onclick = () => modal.remove();
            DOM.modalContainer.appendChild(modal);
        }
        
        function showChoiceModal(title, message, choices) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'modal is-open';
                const buttonsHTML = choices.map(choice => `<button class="btn btn-secondary" data-resolve="${choice.value}">${choice.label}</button>`).join('');
                modal.innerHTML = `<div class="modal-content glass-panel text-center p-8 w-full max-w-sm">
                    <h3 class="text-xl font-bold mb-4">${title}</h3>
                    <p class="text-secondary mb-6">${message}</p>
                    <div class="flex gap-4 justify-center">${buttonsHTML}<button class="btn btn-danger" data-resolve="cancel">Hủy</button></div>
                </div>`;
                
                modal.querySelectorAll('button').forEach(btn => {
                    btn.onclick = () => {
                        modal.remove();
                        resolve(btn.dataset.resolve);
                    };
                });
                DOM.modalContainer.appendChild(modal);
            });
        }

        function getCefrLevelDescription() {
            const value = parseInt(DOM.cefrSlider.value, 10);
            if (value <= 10) return "A1"; if (value <= 30) return "A2"; if (value <= 50) return "B1";
            if (value <= 70) return "B2"; if (value <= 90) return "C1"; return "C2";
        }

        function updateButtonState(button, isLoading, originalHTML, loadingText = 'Đang xử lý...') {
            if (!button) return;
            button.disabled = isLoading;
            if (isLoading) {
                button.innerHTML = `<div class="loader"></div><span class="ml-2">${loadingText}</span>`;
            } else {
                button.innerHTML = originalHTML;
            }
        }

        // --- DATA PROCESSING ---
        function parseAndStructureCSV(vocabText, structuresText) {
            const vocabRows = vocabText.trim().split(/\r?\n/).filter(Boolean);
            const vocab = vocabRows.map((row, index) => {
                const columns = row.split(',').map(c => c.trim().replace(/"/g, ''));
                if (columns.length >= 4 && columns[0]) {
                    return { 
                        id: index + 1, word: columns[0], type: columns[1], 
                        pronunciation: columns[2], meaning: columns[3], 
                        audioUrl: '', structures: [], generated_tasks: null
                    };
                }
                return null;
            }).filter(Boolean);
            
            if (structuresText) {
                const structureRows = structuresText.trim().split(/\r?\n/).filter(Boolean);
                const structures = structureRows.map(row => {
                    const columns = row.split(',').map(c => c.trim().replace(/"/g, ''));
                    if (columns.length >= 2 && columns[0]) return { phrase: columns[0], meaning: columns[1] };
                    return null;
                }).filter(Boolean);

                vocab.forEach(v => {
                    const wordLower = v.word.toLowerCase();
                    const matchRegex = new RegExp(`\\b${wordLower}(s|es|ing|ed)?\\b`, 'i');
                    v.structures = structures
                        .filter(s => matchRegex.test(s.phrase.toLowerCase()))
                        .map(s => ({...s}));
                });
            }
            localWordList = vocab;
        }

        function renderTable() {
            DOM.dataTableBody.innerHTML = '';
            localWordList.forEach((word, wordIndex) => {
                const row = document.createElement('tr');
                row.className = 'border-b dark:border-slate-700 align-top';
                row.dataset.wordId = word.id;

                const audioIconHTML = word.audioUrl ? `<a href="${word.audioUrl}" target="_blank" title="Nghe"><i class="fas fa-volume-up ml-2 text-blue-500 hover:text-blue-400"></i></a>` : '';
                
                const structuresHTML = word.structures && word.structures.length > 0
                    ? `<div class="mt-3 pt-3 border-t border-slate-200 dark:border-slate-600">
                        <h4 class="font-semibold text-xs uppercase text-slate-400 dark:text-slate-500">Cấu trúc liên quan</h4>
                        <ul class="mt-1 space-y-2">
                            ${word.structures.map((structure, structIndex) => `
                                <li class="text-sm">
                                    <p class="font-semibold" contenteditable="true" data-path="structures[${structIndex}].phrase" data-word-index="${wordIndex}">${structure.phrase}</p>
                                    <p class="text-xs text-slate-500" contenteditable="true" data-path="structures[${structIndex}].meaning" data-word-index="${wordIndex}">${structure.meaning}</p>
                                </li>
                            `).join('')}
                        </ul>
                       </div>`
                    : '';

                const wordInfoHTML = `
                    <td class="p-3">
                        <div class="flex items-center">
                            <p class="font-bold text-base" contenteditable="true" data-path="word" data-word-index="${wordIndex}">${word.word}</p>
                            ${audioIconHTML}
                        </div>
                        <p class="font-mono text-sm text-violet-700 dark:text-violet-400" contenteditable="true" data-path="pronunciation" data-word-index="${wordIndex}">${word.pronunciation}</p>
                        <p class="text-xs text-slate-500" contenteditable="true" data-path="type" data-word-index="${wordIndex}">(${word.type})</p>
                        <p class="mt-2 text-sm" contenteditable="true" data-path="meaning" data-word-index="${wordIndex}">${word.meaning}</p>
                        ${structuresHTML}
                    </td>`;
                
                let tasksHTML = '<span class="text-xs text-gray-400 italic">Chưa có dữ liệu AI.</span>';
                const tasks = word.generated_tasks;

                if (tasks) {
                    const renderTask = (taskData, title, contentRenderer) => {
                        if (!taskData) return `<details class="mt-2"><summary class="task-summary text-red-500">${title} (còn thiếu)</summary></details>`;
                        // REMOVED 'open' attribute to make it collapsed by default
                        return `
                            <details class="mt-2">
                                <summary class="task-summary">${title}</summary>
                                <div class="task-details">
                                    ${contentRenderer(taskData)}
                                </div>
                            </details>`;
                    };

                    const editableP = (path, text) => `<p class="sentence" contenteditable="true" data-path="${path}" data-word-index="${wordIndex}">${text || ''}</p>`;
                    const editableSpan = (path, text) => `<span contenteditable="true" data-path="${path}" data-word-index="${wordIndex}">${text || ''}</span>`;
                    const editableList = (basePath, items) => (items || []).map((item, i) => `<li class="option" contenteditable="true" data-path="${basePath}[${i}]" data-word-index="${wordIndex}">${item}</li>`).join('');

                    // REWRITTEN to render all tasks with details, not as JSON
                    tasksHTML = Object.entries(ALL_TASK_TYPES)
                        .map(([taskType, taskInfo]) => {
                            const taskData = tasks[taskType];
                            if (!taskData) return ''; 
                            
                            let contentHTML = '';
                            switch (taskType) {
                                case 'basic_example':
                                    contentHTML = `<div class="task-content">${editableP(`generated_tasks.basic_example`, taskData)}</div>`;
                                    break;
                                case 'meaning_mcq':
                                    contentHTML = `<div class="task-content"><b>Distractors (VI):</b> <ul>${editableList(`generated_tasks.meaning_mcq.distractors_vi`, taskData.distractors_vi)}</ul></div>`;
                                    break;
                                case 'word_family_mcq':
                                    contentHTML = `<div class="task-content"><p class="sentence">${editableSpan(`generated_tasks.word_family_mcq.sentence`, taskData.sentence || '').replace(taskData.blank_placeholder, `<b>[____]</b>`)}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.word_family_mcq.correct_answer`, taskData.correct_answer || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.word_family_mcq.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'sentence_unscramble':
                                    contentHTML = `<div class="task-content">${editableP(`generated_tasks.sentence_unscramble.correct_sentence`, taskData.correct_sentence || '')}</div>`;
                                    break;
                                case 'error_correction':
                                    contentHTML = `<div class="task-content"><p><b>Incorrect:</b> ${editableSpan(`generated_tasks.error_correction.incorrect_sentence`, taskData.incorrect_sentence || '')}</p><p><b>Correct:</b> ${editableSpan(`generated_tasks.error_correction.correct_sentence`, taskData.correct_sentence || '')}</p></div>`;
                                    break;
                                case 'ipa_fill':
                                    contentHTML = `<div class="task-content"><p><b>Gapped IPA:</b> ${editableSpan(`generated_tasks.ipa_fill.gapped_ipa`, taskData.gapped_ipa || '')}</p><p><b>Correct Vowel:</b> ${editableSpan(`generated_tasks.ipa_fill.correct_vowel`, taskData.correct_vowel || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.ipa_fill.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'collocation_odd_one_out':
                                    contentHTML = `<div class="task-content"><p><b>Question:</b> ${editableSpan(`generated_tasks.collocation_odd_one_out.question`, taskData.question || '')}</p><p><b>Options:</b><ul>${(taskData.options || []).map((opt, i) => `<li class="option ${opt === taskData.answer ? 'correct-answer' : ''}" contenteditable="true" data-path="generated_tasks.collocation_odd_one_out.options[${i}]" data-word-index="${wordIndex}">${opt}</li>`).join('')}</ul></p><p><b>Answer:</b> ${editableSpan(`generated_tasks.collocation_odd_one_out.answer`, taskData.answer || '')}</p></div>`;
                                    break;
                                case 'best_fit_replacement':
                                    contentHTML = `<div class="task-content"><p class="sentence">${editableSpan(`generated_tasks.best_fit_replacement.sentence`, taskData.sentence || '').replace(taskData.word_to_replace, `<b><u>${taskData.word_to_replace}</u></b>`)}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.best_fit_replacement.correct_answer`, taskData.correct_answer || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.best_fit_replacement.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'inference_from_scenario':
                                    contentHTML = `<div class="task-content"><p><b>Scenario:</b> ${editableSpan(`generated_tasks.inference_from_scenario.scenario`, taskData.scenario || '')}</p><p><b>Question:</b> ${editableSpan(`generated_tasks.inference_from_scenario.question`, taskData.question || '')}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.inference_from_scenario.correct_answer`, taskData.correct_answer || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.inference_from_scenario.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'best_paraphrase':
                                     contentHTML = `<div class="task-content"><p><b>Original:</b> ${editableP(`generated_tasks.best_paraphrase.original_sentence`, taskData.original_sentence || '')}</p><p><b>Options:</b><ul>${(taskData.options || []).map((opt, i) => `<li class="option ${opt.is_correct ? 'correct-answer' : ''}" contenteditable="true" data-path="generated_tasks.best_paraphrase.options[${i}].text" data-word-index="${wordIndex}">${opt.text}</li>`).join('')}</ul></p></div>`;
                                     break;
                                case 'antonym_mcq':
                                    contentHTML = `<div class="task-content"><p><b>Context:</b> ${editableSpan(`generated_tasks.antonym_mcq.sentence_context`, taskData.sentence_context || '')}</p><p><b>Keyword:</b> ${editableSpan(`generated_tasks.antonym_mcq.keyword`, taskData.keyword || '')}</p><p><b>Antonym:</b> ${editableSpan(`generated_tasks.antonym_mcq.correct_antonym`, taskData.correct_antonym || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.antonym_mcq.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'tripled_sentence':
                                    contentHTML = `<div class="task-content"><p><b>Keyword:</b> ${editableSpan(`generated_tasks.tripled_sentence.keyword`, taskData.keyword || '')}</p><b>Examples:</b><ul>${editableList(`generated_tasks.tripled_sentence.examples`, taskData.examples)}</ul></div>`;
                                    break;
                                case 'main_idea':
                                    contentHTML = `<div class="task-content"><p><b>Paragraph:</b> ${editableSpan(`generated_tasks.main_idea.paragraph`, taskData.paragraph || '')}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.main_idea.correct_answer`, taskData.correct_answer || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.main_idea.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'paragraph_completion':
                                    contentHTML = `<div class="task-content"><p><b>Body:</b> ${editableSpan(`generated_tasks.paragraph_completion.paragraph_body`, taskData.paragraph_body || '')}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.paragraph_completion.correct_conclusion`, taskData.correct_conclusion || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.paragraph_completion.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'argument_strengthening':
                                    contentHTML = `<div class="task-content"><p><b>Argument:</b> ${editableSpan(`generated_tasks.argument_strengthening.argument_text`, taskData.argument_text || '')}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.argument_strengthening.correct_evidence`, taskData.correct_evidence || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.argument_strengthening.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'argument_weakening':
                                    contentHTML = `<div class="task-content"><p><b>Argument:</b> ${editableSpan(`generated_tasks.argument_weakening.argument_text`, taskData.argument_text || '')}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.argument_weakening.correct_weakener`, taskData.correct_weakener || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.argument_weakening.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'tone_purpose_analysis':
                                    contentHTML = `<div class="task-content"><p><b>Paragraph:</b> ${editableSpan(`generated_tasks.tone_purpose_analysis.paragraph`, taskData.paragraph || '')}</p><p><b>Question:</b> ${editableSpan(`generated_tasks.tone_purpose_analysis.question`, taskData.question || '')}</p><p><b>Answer:</b> ${editableSpan(`generated_tasks.tone_purpose_analysis.correct_answer`, taskData.correct_answer || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.tone_purpose_analysis.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                                case 'sentence_role_analysis':
                                    contentHTML = `<div class="task-content"><p><b>Paragraph:</b> ${editableSpan(`generated_tasks.sentence_role_analysis.paragraph`, taskData.paragraph || '')}</p><p><b>Role of Sentence ${taskData.highlighted_sentence_index + 1}:</b> ${editableSpan(`generated_tasks.sentence_role_analysis.correct_role`, taskData.correct_role || '')}</p><p><b>Distractors:</b> <ul>${editableList(`generated_tasks.sentence_role_analysis.distractors`, taskData.distractors)}</ul></p></div>`;
                                    break;
                            }
                            return renderTask(taskData, taskInfo.title, () => contentHTML);
                        })
                        .filter(Boolean).join('');
                }

                const aiStatusIcon = tasks ? `<i class="fas fa-check-circle text-2xl text-green-500"></i>` : `<i class="fas fa-times-circle text-2xl text-gray-400"></i>`;

                row.innerHTML = `
                    <td class="p-3 text-center"><input type="checkbox" class="row-checkbox" data-word-id="${word.id}"></td>
                    ${wordInfoHTML}
                    <td class="p-3">${tasksHTML}</td>
                    <td class="p-3 text-center align-middle ai-status-cell">${aiStatusIcon}</td>
                `;
                DOM.dataTableBody.appendChild(row);
            });
        }
        
        function updateNestedObject(obj, path, value) {
            const keys = path.replace(/\[(\w+)\]/g, '.$1').replace(/^\./, '').split('.');
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                const key = keys[i];
                if (current[key] === undefined || current[key] === null) { 
                    if (Number.isInteger(parseInt(keys[i+1], 10))) {
                        current[key] = [];
                    } else {
                        current[key] = {};
                    }
                }
                current = current[key];
            }
            current[keys[keys.length - 1]] = value;
        }

        // --- AI & API ---
        
        function getPromptForBatch(batch, overwriteAll = false) {
            const cefrLevel = getCefrLevelDescription();
            const batchInput = batch.map(wordData => {
                const taskKeys = Object.keys(ALL_TASK_TYPES);
                const missingTasks = overwriteAll ? taskKeys : taskKeys.filter(type => !wordData.generated_tasks || !wordData.generated_tasks[type]);
                return {
                    id: wordData.id,
                    word: wordData.word,
                    type: wordData.type,
                    meaning: wordData.meaning,
                    pronunciation: wordData.pronunciation,
                    structures: wordData.structures,
                    tasks_to_generate: missingTasks
                };
            });

            return `
# MISSION & ROLE
You are a **Master Instructional Designer** specializing in English Language Testing (ELT). Your mission is to craft high-quality, pedagogically sound assessment items. You are not a mere content generator; you are an expert in cognitive science and language acquisition, creating "cognitive puzzles" that test and reinforce a learner's understanding of vocabulary in a comprehensive, meaningful way.

# GUIDING PRINCIPLES
- **Pedagogical Soundness**: Every item must have a clear learning objective.
- **CEFR Alignment**: All content, from example sentences to distractors, MUST be appropriate for the target **${cefrLevel}** level.
- **Context is King**: Leverage the provided \`structures\` to create authentic, natural-sounding contexts. Avoid generic or nonsensical sentences.
- **Plausible Distractors**: The art of a good question lies in its distractors. They should be tempting to a learner who has a partial understanding but clearly incorrect to one who has mastered the concept.
- **Distractor Parity**: To prevent "longest answer" bias, all distractors in multiple-choice questions MUST be of similar length, complexity, and grammatical structure to the correct answer. The choice should be based on meaning, not pattern recognition.
- **Creativity & Variety**: Avoid repetitive sentence structures. Showcase the vocabulary in diverse and interesting scenarios. Example: A good passage in a self-help book, the "letters to the editor" section in a newspaper, the postscript in an old letter, the subject line of a work email, a hastily written line in a diary, the description of a special dish on a menu, the ingredient list for a baking recipe, the chorus of a famous song, a haiku verse, a memorable line of dialogue in a movie script, a crossed-out item on a grocery list, the work experience description on a CV, the opening paragraph of a cover letter, a short greeting on the back of a postcard, a penalty clause in a contract, the name and date of birth on a birth certificate, the line stating the major on a university diploma, an entry stamp in a passport, the seat number and showtime on a movie ticket, the total amount line on a receipt, the washing instructions on a clothing tag, the calorie count on food packaging, a troubleshooting step in an instruction manual, the summary paragraph of a blog post, a short comment with an emoji, a line of translated subtitles, a bullet point on a presentation slide, the conclusion section in a weekly report, a line designating an heir in a will, the expiration date on a warranty card, the sign for a small alley, the regional code on a license plate, a single word tattooed on a wrist, a sentence in an oath, a quote at the bottom of a book page, an advertising slogan on a large billboard, the wordmark of a brand, a teacher's comment at the end of a test, the copyright notice at the bottom of a webpage, a thought bubble of a comic book character, the headline of a press release, a phone number scribbled on the edge of a notebook, the "dress code" note in a wedding invitation, a decision recorded in meeting minutes, the thank-you note at the end of a speech, a line of prophecy in a myth, the clue section of a crossword puzzle, a word in a magic spell, the rule about silence in a library, the dosage instructions on a prescription, a blood test result value, a product code in a catalog, a "birthday" note on a calendar date, the legend for a symbol on a map, the definition of a word in a dictionary, a date in a historical article, the dedication on the first page of a book, the signature at the end of a pledge, the violation recorded in a penalty notice, the star rating in an online review, the name of a person on a family tree, an "I'm busy" auto-reply message, a line of comment in a programming code, the title of a promotional notification, the punchline of a written joke, the first article in a manifesto, the legal representative's name on a business license, the coordinates written on a piece of paper in a bottle, the date of birth engraved on a tombstone, the main question in a forum thread.

# INPUT & OUTPUT SPECIFICATION

## INPUT
You will receive a JSON array. For each object, you MUST generate the tasks listed in the \`tasks_to_generate\` array.
\`\`\`json
${JSON.stringify(batchInput, null, 2)}
\`\`\`

## OUTPUT
You **MUST** return **ONLY** a single, valid JSON array. Do **NOT** include any explanatory text, markdown formatting like \`\`\`json, or any other content outside of the JSON array itself. Each object in the output array must contain the original \`id\` and a \`generated_tasks\` object containing ONLY the newly generated tasks.

**Example Output Structure for a single word:**
\`\`\`json
{
  "id": 1,
  "generated_tasks": {
    "basic_example": "A clear, contextual sentence using the word.",
    "meaning_mcq": { "distractors_en": ["word1", "word2"], "distractors_vi": ["nghĩa1", "nghĩa2"] }
  }
}
\`\`\`

# DETAILED TASK GUIDELINES & HIGH-QUALITY EXAMPLES

**1. \`basic_example\`**:
- **Objective**: Provide the most clear, simple, and contextually appropriate example sentence.
- **High-Quality Example** (for "ubiquitous"): "In today's world, smartphones and Wi-Fi have become ubiquitous."
- **Poor Example**: "The ubiquitousness of the problem was startling." (Uses a different word form, less common).

**2. \`meaning_mcq\`**:
- **Objective**: Test semantic understanding with plausible distractors.
- **Strategy**: Distractors should be related (e.g., other feelings for an emotion word) or be common mistakes.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "diligent"): distractors_en: ["lazy", "intelligent", "creative"], distractors_vi: ["lười biếng", "thông minh", "sáng tạo"].

**3. \`word_family_mcq\`**:
- **Objective**: Test knowledge of different forms of a word.
- **Strategy**: Distractors MUST be other members of the word family or commonly confused forms.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "economy"): sentence: "The government needs to _______ the national budget carefully.", blank_placeholder: "[BLANK]", correct_answer: "economize", distractors: ["economic", "economical", "economics"].

**4. \`sentence_unscramble\`**:
- **Objective**: Test understanding of syntax and word order.
- **High-Quality Example** (for "collaborate"): "The two rival companies agreed to collaborate on the new project."

**5. \`error_correction\`**:
- **Objective**: Test ability to spot subtle grammatical or collocational errors.
- **Strategy**: Focus on common errors like prepositions, articles, or verb tenses, not obvious spelling mistakes.
- **High-Quality Example** (for "responsible"): incorrect_sentence: "He is responsible at managing the team.", correct_sentence: "He is responsible for managing the team."

**6. \`ipa_fill\`**:
- **Objective**: Test phonemic awareness.
- **Strategy**: Gap a single, distinctive vowel or consonant sound. Distractors should be phonetically similar.
- **High-Quality Example** (for "heat" /hiːt/): gapped_ipa: "/h_t/", correct_vowel: "iː", distractors: ["ɪ", "e", "eɪ"].

**7. \`collocation_odd_one_out\`**:
- **Objective**: Test knowledge of common word pairings (collocations).
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "effort"): question: "Which verb does NOT typically collocate with 'effort'?", options: ["make", "put in", "do", "save"], answer: "do".

**8. \`best_fit_replacement\`**:
- **Objective**: Test understanding of semantic nuance and connotation.
- **Strategy**: Distractors should be synonyms but less precise or appropriate for the specific context.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "crucial"): sentence: "It is **crucial** that you submit the report by Friday.", word_to_replace: "crucial", correct_answer: "vital", distractors: ["important", "helpful", "suggested"].

**9. \`inference_from_scenario\`**:
- **Objective**: Test reading comprehension and logical deduction.
- **Strategy**: The answer must be strongly implied by the text, not explicitly stated.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "reluctant"): scenario: "John looked at the huge plate of Brussels sprouts. He slowly picked up his fork but didn't take a bite. 'My mother said I have to eat them,' he sighed.", question: "How does John feel about eating the Brussels sprouts?", correct_answer: "He is reluctant to eat them.", distractors: ["He is excited to eat them.", "He is allergic to them.", "He has never tried them before."].

**10. \`best_paraphrase\`**:
- **Objective**: Test ability to recognize the same meaning expressed differently.
- **Strategy**: Distractors should alter the original meaning in a subtle way (e.g., changing the certainty, scope, or focus).
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "mitigate"): original_sentence: "The new flood barriers are designed to mitigate the effects of storm surges.", options: [{"text": "The barriers aim to lessen the impact of storm surges.", "similarity": 100, "is_correct": true}, {"text": "The barriers will completely prevent all damage from storms.", "similarity": 60, "is_correct": false}].

**11. \`antonym_mcq\`**:
- **Objective**: Test knowledge of opposites, with a twist.
- **Strategy**: The most effective distractors are often **synonyms** of the keyword, forcing the learner to carefully read the question.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "expand"): sentence_context: "The company plans to **expand** its operations in Asia.", keyword: "expand", correct_antonym: "contract", distractors: ["grow", "enlarge", "develop"].

**12. \`tripled_sentence\`**:
- **Objective**: Show understanding of a word's different uses or shades of meaning.
- **Strategy**: Use the keyword in three distinct, non-repetitive contexts.
- **High-Quality Example** (for "policy"): keyword: "policy", examples: ["The company has a strict no-smoking policy.", "The government's new economic policy was met with criticism.", "It's a good policy to always check your work before submitting it."].

**13. \`main_idea\`**:
- **Objective**: Test ability to synthesize information and identify the central point.
- **Strategy**: Distractors should be: a true but minor detail, a statement that is too broad, or a misinterpretation of the paragraph's focus.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "sustainable"): paragraph: "Sustainable agriculture focuses on long-term solutions. It avoids harsh chemicals that deplete the soil and seeks to conserve water. The goal is to produce healthy food for today's population without compromising the ability of future generations to do the same.", correct_answer: "Sustainable agriculture balances present needs with future resources.", distractors: ["Sustainable agriculture avoids harsh chemicals.", "All farming should be sustainable."].

**14. \`paragraph_completion\`**:
- **Objective**: Test logical flow and coherence.
- **Strategy**: The correct answer should logically follow from the preceding sentences. Distractors might be contradictory, irrelevant, or introduce a new topic abruptly.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "innovative"): paragraph_body: "The company's research team spent two years developing the new material. It's lighter, stronger, and more flexible than anything on the market. This breakthrough has already attracted interest from the aerospace and automotive industries...", correct_conclusion: "Consequently, the company is poised to become a leader in the field.", distractors: ["However, the team was disappointed with the results.", "The company also produces office furniture."].

**15. \`argument_strengthening\`**:
- **Objective**: Test critical thinking and the ability to evaluate evidence.
- **Strategy**: The correct answer provides a new piece of information or a logical reason that directly supports the argument's conclusion.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "mandatory"): argument_text: "The city council argues that bicycle helmets should be mandatory for all riders to reduce head injuries.", correct_evidence: "A recent study in a similar city showed a 40% decrease in serious head injuries after they implemented a mandatory helmet law.", distractors: ["Bicycle helmets can be expensive for some residents.", "Many cyclists enjoy the feeling of riding without a helmet."].

**16. \`argument_weakening\`**:
- **Objective**: Test the ability to identify flaws or counter-evidence.
- **Strategy**: The correct answer should expose a flaw in the argument's logic or provide evidence that contradicts its conclusion.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "censorship"): argument_text: "The activist group argues that censoring certain online content is necessary to protect children from harmful material.", correct_weakener: "Studies have shown that such censorship often leads to a 'Streisand effect,' where the banned content becomes even more popular and widely distributed.", distractors: ["Protecting children is a very important goal."].

**17. \`tone_purpose_analysis\`**:
- **Objective**: Test the ability to discern an author's attitude or intent.
- **Strategy**: Distractors should be plausible but less accurate descriptions of the tone (e.g., 'objective' vs. 'cautious', 'enthusiastic' vs. 'biased').
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "skeptical"): paragraph: "While the new 'super-juice' is marketed as a miracle cure, its health claims are based on a single, small-scale study funded by its own parent company. Independent researchers have not yet replicated these extraordinary findings.", question: "The author's tone is best described as...", correct_answer: "skeptical and cautionary", distractors: ["enthusiastic and supportive", "objective and informative"].

**18. \`sentence_role_analysis\`**:
- **Objective**: Test understanding of how sentences function within a larger argument.
- **Strategy**: The correct answer accurately describes the logical function of one sentence in relation to another. Distractors can describe the roles of other sentences in the paragraph.
- **Constraint**: Ensure all options have comparable length and complexity.
- **High-Quality Example** (for "illustrate"): paragraph: "[1] Many animals have developed incredible methods of camouflage. [2] For instance, the stick insect is almost indistinguishable from a twig, which helps it avoid predators.", "highlighted_sentence_index": 1, "correct_role": "To provide a specific example that illustrates the claim made in sentence 1.", "distractors": ["To state the main idea of the paragraph.", "To contradict the claim made in sentence 1."].

---
**FINAL INSTRUCTIONS**
- **Proficiency Level**: All generated content must be strictly aligned with the **${cefrLevel}** level.
- **Format**: Return only a valid JSON array.
- **Begin!**`;
        }


        async function callGeminiAPI(prompt, model) {
            const apiKey = DOM.geminiApiKeyInput.value.trim();
            if (!apiKey) throw new Error("Vui lòng nhập Google Gemini API Key.");
            
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json" }
            };
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`Lỗi API Gemini: ${errorBody.error.message}`);
            }
            const result = await response.json();
            const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!responseText) throw new Error("Cấu trúc phản hồi API không hợp lệ.");
            try {
                return JSON.parse(responseText);
            } catch (e) {
                console.error("Lỗi parse JSON từ API:", responseText);
                throw new Error("Kết quả trả về từ AI không phải là JSON hợp lệ.");
            }
        }

        function processAiResults(aiDataArray) {
            const successfulWords = [];
            const failedWords = [];

            if (!Array.isArray(aiDataArray)) {
                showAlert("Lỗi nghiêm trọng", "error", "Kết quả AI trả về không phải là một mảng. Vui lòng kiểm tra lại output từ Gemini.", JSON.stringify(aiDataArray, null, 2));
                return;
            }
            
            aiDataArray.forEach(enrichedData => {
                if (!enrichedData || typeof enrichedData.id === 'undefined' || !enrichedData.generated_tasks) {
                    failedWords.push({ reason: "Cấu trúc không hợp lệ hoặc thiếu ID/tasks.", data: enrichedData });
                    return;
                }

                const wordToUpdate = localWordList.find(w => w.id === enrichedData.id);
                if (wordToUpdate) {
                    if (!wordToUpdate.generated_tasks) {
                        wordToUpdate.generated_tasks = {};
                    }
                    Object.assign(wordToUpdate.generated_tasks, enrichedData.generated_tasks);
                    successfulWords.push(wordToUpdate.word);
                } else {
                    failedWords.push({ reason: `Không tìm thấy từ với ID: ${enrichedData.id}`, data: enrichedData });
                }
            });

            renderTable();

            if (failedWords.length > 0) {
                const errorDetails = failedWords.map(f => `Lý do: ${f.reason}\nDữ liệu: ${JSON.stringify(f.data, null, 2)}`).join('\n\n');
                showAlert(`Hoàn tất với ${failedWords.length} lỗi.`, 'error', errorDetails);
            } else {
                showAlert(`Làm giàu thành công cho ${successfulWords.length} từ!`, 'success');
            }
        }

        // --- WORD EXPORT FUNCTIONS (REWRITTEN & FIXED) ---
        const NO_BORDER = {
            top: { style: BorderStyle.NONE, size: 0, color: "auto" },
            bottom: { style: BorderStyle.NONE, size: 0, color: "auto" },
            left: { style: BorderStyle.NONE, size: 0, color: "auto" },
            right: { style: BorderStyle.NONE, size: 0, color: "auto" },
            insideHorizontal: { style: BorderStyle.NONE, size: 0, color: "auto" },
            insideVertical: { style: BorderStyle.NONE, size: 0, color: "auto" },
        };
        
        function renderSingleQuestionForDocx(wordData, taskType, taskData, qCounter) {
            const taskInfo = ALL_TASK_TYPES[taskType];
            if (!taskData || !taskInfo) return null;

            const docElements = [];
            let answer = null;
            const questionPrefix = `Question ${qCounter}:`;

            const createMCQ = (questionText, correctAnswer, distractors) => {
                if (!correctAnswer || !Array.isArray(distractors) || distractors.length === 0) return;
                docElements.push(new Paragraph({ children: [new TextRun({ text: `${questionPrefix} `, bold: true }), new TextRun({ text: `[${taskInfo.title}] `, italics: true }), new TextRun(questionText)], spacing: { before: 200 } }));
                const allChoices = [correctAnswer, ...distractors];
                const shuffledChoices = [...allChoices].sort(() => 0.5 - Math.random());
                const correctIndex = shuffledChoices.findIndex(c => c === correctAnswer);
                answer = ["A", "B", "C", "D"][correctIndex];
                const options = shuffledChoices.map((choice, i) => ({ label: `${["A", "B", "C", "D"][i]}. `, text: String(choice) }));
                if (allChoices.join("").length > 150) {
                    docElements.push(...options.map(opt => new Paragraph({ children: [new TextRun({ text: opt.label, bold: true }), new TextRun(opt.text)] })));
                } else {
                    const tableRows = [];
                    for (let i = 0; i < options.length; i += 2) {
                        tableRows.push(new TableRow({ children: [
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: options[i]?.label || "", bold: true }), new TextRun(options[i]?.text || "")] })], borders: NO_BORDER, width: { size: 50, type: WidthType.PERCENTAGE } }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: options[i + 1]?.label || "", bold: true }), new TextRun(options[i + 1]?.text || "")] })], borders: NO_BORDER, width: { size: 50, type: WidthType.PERCENTAGE } })
                        ]}));
                    }
                    docElements.push(new Table({ rows: tableRows, width: { size: 100, type: WidthType.PERCENTAGE }, borders: NO_BORDER }));
                }
            };

            const createFillInBlank = (questionText, correctAnswerText) => {
                 docElements.push(new Paragraph({ children: [new TextRun({ text: `${questionPrefix} `, bold: true }), new TextRun({ text: `[${taskInfo.title}] `, italics: true }), new TextRun(questionText)], spacing: { before: 200 } }));
                 docElements.push(new Paragraph("Answer: __________________________________________________"));
                 answer = correctAnswerText;
            };
            
            const createSimpleText = (title, content) => {
                docElements.push(new Paragraph({ children: [new TextRun({ text: `${questionPrefix} `, bold: true }), new TextRun({ text: `[${taskInfo.title}] `, italics: true }), new TextRun(title)], spacing: { before: 200 } }));
                if(Array.isArray(content)) {
                    content.forEach(item => docElements.push(new Paragraph({ text: `- ${item}`, bullet: { level: 0 } })));
                } else {
                    docElements.push(new Paragraph(content));
                }
                answer = "Tự luận";
            };

            switch (taskType) {
                case 'meaning_mcq': createMCQ(`What is the meaning of "${wordData.word}"?`, wordData.meaning, taskData.distractors_vi); break;
                case 'word_family_mcq': createMCQ((taskData.sentence || '').replace(taskData.blank_placeholder, '______'), taskData.correct_answer, taskData.distractors); break;
                case 'best_paraphrase':
                    const correctPara = taskData.options?.find(o => o.is_correct)?.text;
                    const incorrectPara = taskData.options?.filter(o => !o.is_correct).map(o => o.text);
                    createMCQ(taskData.original_sentence, correctPara, incorrectPara);
                    break;
                case 'main_idea': createMCQ(taskData.paragraph, taskData.correct_answer, taskData.distractors); break;
                case 'antonym_mcq': createMCQ(taskData.sentence_context, taskData.correct_antonym, taskData.distractors); break;
                case 'error_correction': createFillInBlank(`Correct the following sentence: ${taskData.incorrect_sentence}`, taskData.correct_sentence); break;
                case 'sentence_unscramble':
                    const scrambled = (taskData.correct_sentence || '').split(' ').sort(() => 0.5 - Math.random()).join(' / ');
                    createFillInBlank(`Unscramble the words to form a correct sentence: ${scrambled}`, taskData.correct_sentence);
                    break;
                case 'ipa_fill': createMCQ(`Fill in the blank for /${wordData.word}/: ${taskData.gapped_ipa}`, taskData.correct_vowel, taskData.distractors); break;
                case 'collocation_odd_one_out': createMCQ(taskData.question, taskData.answer, taskData.options.filter(o => o !== taskData.answer)); break;
                case 'best_fit_replacement': createMCQ(taskData.sentence.replace(taskData.word_to_replace, `__${taskData.word_to_replace}__`), taskData.correct_answer, taskData.distractors); break;
                case 'inference_from_scenario': createMCQ(taskData.scenario, taskData.correct_answer, taskData.distractors); break;
                case 'paragraph_completion': createMCQ(taskData.paragraph_body, taskData.correct_conclusion, taskData.distractors); break;
                case 'argument_strengthening': createMCQ(taskData.argument_text, taskData.correct_evidence, taskData.distractors); break;
                case 'argument_weakening': createMCQ(taskData.argument_text, taskData.correct_weakener, taskData.distractors); break;
                case 'tone_purpose_analysis': createMCQ(taskData.paragraph, taskData.correct_answer, taskData.distractors); break;
                case 'sentence_role_analysis': createMCQ(taskData.paragraph, taskData.correct_role, taskData.distractors); break;
                case 'basic_example': createSimpleText('Write a sentence using this word.', taskData); break;
                case 'tripled_sentence': createSimpleText(`Examples for "${taskData.keyword}":`, taskData.examples); break;
            }
            
            return docElements.length > 0 ? { docElements, answer } : null;
        }

        function selectQuestionsForTest(totalQuestions) {
            const allPossibleQuestions = [];
            const levelConfigs = document.querySelectorAll('#export-levels-container .level-config');

            localWordList.forEach(wordData => {
                if (wordData.generated_tasks) {
                    for (const taskType in wordData.generated_tasks) {
                        const taskInfo = ALL_TASK_TYPES[taskType];
                        if (taskInfo) {
                            allPossibleQuestions.push({
                                level: taskInfo.level,
                                wordData: wordData,
                                taskType: taskType,
                                taskData: wordData.generated_tasks[taskType]
                            });
                        }
                    }
                }
            });

            let selectedQuestions = [];
            let totalAdded = 0;
            levelConfigs.forEach(config => {
                const checkbox = config.querySelector('input[type="checkbox"]');
                if (!checkbox.checked) return;

                const level = Number(checkbox.dataset.level);
                const percentage = Number(config.querySelector('input[type="number"]').value);
                const questionsForThisLevel = Math.round(totalQuestions * (percentage / 100));
                
                const pool = allPossibleQuestions.filter(q => q.level === level);
                const shuffledPool = pool.sort(() => 0.5 - Math.random());
                selectedQuestions.push(...shuffledPool.slice(0, questionsForThisLevel));
                totalAdded += questionsForThisLevel;
            });
            
            while (selectedQuestions.length > totalQuestions) { selectedQuestions.pop(); }
            while (selectedQuestions.length < totalQuestions && selectedQuestions.length < allPossibleQuestions.length) {
                const remaining = allPossibleQuestions.filter(p => !selectedQuestions.includes(p));
                if(remaining.length === 0) break;
                selectedQuestions.push(remaining[0]);
            }

            return selectedQuestions.sort(() => 0.5 - Math.random());
        }

        async function generateAndDownloadRandomTests() {
            const mainTitle = document.getElementById('export-main-title').value;
            const subtitle = document.getElementById('export-subtitle').value;
            const testCodeBase = document.getElementById('export-test-code-base').value;
            const totalQuestions = Number(document.getElementById('export-total-questions').value);
            const numVersions = Number(document.getElementById('export-num-versions').value);
            const strategy = document.querySelector('input[name="strategy"]:checked').value;
            const validationMsg = DOM.exportValidationMessage;

            const totalPercentage = Array.from(document.querySelectorAll('#export-levels-container .level-config input[type="number"]')).reduce((sum, input) => sum + (input.disabled ? 0 : Number(input.value)), 0);
            if (totalPercentage !== 100) {
                validationMsg.textContent = 'Tổng tỷ lệ phải bằng 100%.'; return;
            }
            if (totalQuestions <= 0 || numVersions <= 0) {
                validationMsg.textContent = 'Số câu hỏi và số mã đề phải lớn hơn 0.'; return;
            }
            validationMsg.textContent = '';

            const allTestVersions = [];
            let baseQuestionSet = null;

            for (let i = 0; i < numVersions; i++) {
                let currentQuestionSet;
                if (strategy === 'shuffle' && i === 0) {
                    baseQuestionSet = selectQuestionsForTest(totalQuestions);
                    currentQuestionSet = baseQuestionSet;
                } else if (strategy === 'shuffle') {
                    currentQuestionSet = [...baseQuestionSet].sort(() => 0.5 - Math.random());
                } else {
                    currentQuestionSet = selectQuestionsForTest(totalQuestions);
                }
                
                allTestVersions.push({ testCode: `${testCodeBase}${i + 1}`, questions: currentQuestionSet });
            }

            await exportTestsAndAnswerKeys(allTestVersions, mainTitle, subtitle);
            DOM.wordExportModal.classList.remove('is-open');
        }

        async function exportTestsAndAnswerKeys(allTestVersions, mainTitle, subtitle) {
            const allTestSections = [];
            const answerKeyDocChildren = [new Paragraph({ children: [new TextRun({ text: "ĐÁP ÁN TỔNG HỢP", bold: true })], heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER })];

            for (const version of allTestVersions) {
                const { testCode, questions } = version;
                const testDocChildren = [];
                const currentAnswerKey = {};
                
                testDocChildren.push(new Paragraph({ children: [new TextRun({ text: mainTitle, bold: true })], heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER }));
                if (subtitle) testDocChildren.push(new Paragraph({ children: [new TextRun({ text: subtitle, bold: true })], alignment: AlignmentType.CENTER }));
                testDocChildren.push(new Paragraph({ text: `MÃ ĐỀ: ${testCode}`, alignment: AlignmentType.CENTER, spacing: { after: 200 } }));

                // FIX: Use index from forEach for sequential numbering
                questions.forEach((questionItem, index) => {
                    const qCounter = index + 1;
                    const result = renderSingleQuestionForDocx(questionItem.wordData, questionItem.taskType, questionItem.taskData, qCounter);
                    if (result && result.docElements) {
                        testDocChildren.push(...result.docElements);
                        if (result.answer) {
                            currentAnswerKey[qCounter] = result.answer;
                        }
                    }
                });

                allTestSections.push({
                    properties: { type: SectionType.NEXT_PAGE, page: { pageNumbers: { start: 1 } } },
                    footers: { default: new Footer({ children: [ new Paragraph({ alignment: AlignmentType.CENTER, children: [ new TextRun(`Mã đề ${testCode} - Trang `), new TextRun({ children: [PageNumber.CURRENT] }), new TextRun("/"), new TextRun({ children: [PageNumber.TOTAL_PAGES_IN_SECTION] }) ] }) ] }) },
                    children: testDocChildren,
                });

                answerKeyDocChildren.push(new Paragraph({ children: [new TextRun({ text: `MÃ ĐỀ ${testCode}`, bold: true })], heading: HeadingLevel.HEADING_2, spacing: { before: 400 } }));
                const answerRows = [];
                const questionNumbers = Object.keys(currentAnswerKey).sort((a,b) => Number(a) - Number(b));
                for (let i = 0; i < questionNumbers.length; i += 5) {
                    const chunk = questionNumbers.slice(i, i + 5);
                    answerRows.push(new TableRow({
                        children: chunk.map(qNum => new TableCell({ children: [new Paragraph(`${qNum}. ${currentAnswerKey[qNum]}`)], borders: NO_BORDER }))
                    }));
                }
                answerKeyDocChildren.push(new Table({ rows: answerRows, width: { size: 100, type: WidthType.PERCENTAGE }, borders: NO_BORDER }));
            }

            const testDoc = new Document({ sections: allTestSections });
            const testBlob = await Packer.toBlob(testDoc);
            downloadFile(testBlob, `DeThiTongHop_${DOM.testIdInput.value}.docx`);

            const answerDoc = new Document({ sections: [{ children: answerKeyDocChildren }] });
            const answerBlob = await Packer.toBlob(answerDoc);
            downloadFile(answerBlob, `DapAnTongHop_${DOM.testIdInput.value}.docx`);
            
            showAlert('Đã tạo và tải xuống thành công bộ đề thi và đáp án!', 'success');
        }

        async function exportAllQuestions() {
            const sortOrder = document.querySelector('input[name="sort-order"]:checked').value;
            const docChildren = [];
            let qCounter = 1;

            docChildren.push(new Paragraph({ text: `Ngân hàng câu hỏi: ${DOM.testTitleInput.value}`, heading: HeadingLevel.TITLE, alignment: AlignmentType.CENTER }));

            if (sortOrder === 'word') {
                localWordList.forEach(wordData => {
                    if (!wordData.generated_tasks) return;
                    docChildren.push(new Paragraph({ text: wordData.word, heading: HeadingLevel.HEADING_1, spacing: { before: 400 } }));
                    
                    for (const taskType in wordData.generated_tasks) {
                        const taskData = wordData.generated_tasks[taskType];
                        const result = renderSingleQuestionForDocx(wordData, taskType, taskData, qCounter);
                        if (result && result.docElements) {
                            docChildren.push(...result.docElements);
                            qCounter++;
                        }
                    }
                });
            } else { // sortOrder === 'level'
                // FIX: Group data first, then render with correct counter
                const questionsByLevel = { 1: [], 2: [], 3: [], 4: [] };
                localWordList.forEach(wordData => {
                    if (wordData.generated_tasks) {
                        for (const taskType in wordData.generated_tasks) {
                            const taskInfo = ALL_TASK_TYPES[taskType];
                            if (taskInfo && questionsByLevel[taskInfo.level]) {
                                questionsByLevel[taskInfo.level].push({ wordData, taskType, taskData: wordData.generated_tasks[taskType] });
                            }
                        }
                    }
                });

                for (const level in questionsByLevel) {
                    if (questionsByLevel[level].length > 0) {
                        docChildren.push(new Paragraph({ text: LEVEL_DEFINITIONS[level], heading: HeadingLevel.HEADING_1, spacing: { before: 400 } }));
                        questionsByLevel[level].forEach(qItem => {
                            const result = renderSingleQuestionForDocx(qItem.wordData, qItem.taskType, qItem.taskData, qCounter);
                            if (result && result.docElements) {
                                docChildren.push(...result.docElements);
                                qCounter++;
                            }
                        });
                    }
                }
            }

            const doc = new Document({ sections: [{ children: docChildren }] });
            const blob = await Packer.toBlob(doc);
            downloadFile(blob, `NganHangCauHoi_${DOM.testIdInput.value}.docx`);
            showAlert('Đã tạo và tải xuống thành công toàn bộ ngân hàng câu hỏi!', 'success');
            DOM.wordExportModal.classList.remove('is-open');
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        // --- FIREBASE & AUTHENTICATION ---
        async function uploadToFirebase() {
            const testId = DOM.testIdInput.value.trim();
            const title = DOM.testTitleInput.value.trim();
            if (!testId || !title || localWordList.length === 0) {
                return showAlert("Vui lòng nhập ID, Tiêu đề và xử lý dữ liệu.", 'error');
            }
            
            const button = DOM.uploadBtn;
            const originalHTML = button.innerHTML;
            updateButtonState(button, true, '', 'Đang lưu...');
            DOM.uploadLog.textContent = 'Đang chuẩn bị dữ liệu...';

            try {
                const batch = writeBatch(db);
                const vocabSetRef = doc(db, "vocab_sets", testId);
                
                batch.set(vocabSetRef, {
                    title: title,
                    wordCount: localWordList.length,
                    level: getCefrLevelDescription(),
                    updatedAt: serverTimestamp()
                }, { merge: true });

                const wordsCollectionRef = collection(db, "vocab_sets", testId, "words");
                
                localWordList.forEach((wordData) => {
                    const wordDocRef = doc(wordsCollectionRef, String(wordData.id));
                    batch.set(wordDocRef, wordData);
                });

                DOM.uploadLog.textContent = `Đang lưu ${localWordList.length} từ vựng...`;
                await batch.commit();

                DOM.uploadLog.textContent = 'Lưu THÀNH CÔNG!';
                showAlert(`Đã lưu thành công bộ từ vựng "${title}"!`, 'success');
                setTimeout(() => { DOM.uploadLog.textContent = ''; }, 5000);

            } catch (error) {
                console.error("Error uploading to Firebase:", error);
                DOM.uploadLog.textContent = `LỖI: ${error.message}`;
                showAlert("Lỗi khi lưu dữ liệu", 'error', error.message);
            } finally {
                updateButtonState(button, false, originalHTML);
            }
        }

        async function loadAndPopulateTestData(testId) {
            showAlert("Đang tải dữ liệu bộ từ vựng...");
            const docRef = doc(db, "vocab_sets", testId);

            try {
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const testData = docSnap.data();
                    
                    DOM.pageTitle.textContent = "Chỉnh sửa Bộ từ vựng";
                    DOM.testIdInput.value = testId;
                    DOM.testIdInput.disabled = true;
                    DOM.testTitleInput.value = testData.title || "";

                    const wordsColRef = collection(db, "vocab_sets", testId, "words");
                    const wordsSnapshot = await getDocs(wordsColRef);
                    
                    if (!wordsSnapshot.empty) {
                        console.log(`Found ${wordsSnapshot.size} words in sub-collection (new structure).`);
                        localWordList = wordsSnapshot.docs.map(doc => doc.data());
                    } else if (testData.wordList && Array.isArray(testData.wordList)) {
                        console.warn(`'words' sub-collection not found. Falling back to 'wordList' field (old structure). Consider migrating this data.`);
                        localWordList = testData.wordList;
                        showAlert("Cảnh báo: Dữ liệu cũ", 'info', 'Bộ từ vựng này đang dùng cấu trúc dữ liệu cũ. Sau khi bấm "Cập nhật", nó sẽ được tự động chuyển sang cấu trúc mới, hiệu quả hơn.');
                    } else {
                        console.log("No vocabulary data found.");
                        localWordList = [];
                    }
                    
                    localWordList.sort((a, b) => (a.id || 0) - (b.id || 0));

                    localWordList.forEach(word => {
                        if (!word.generated_tasks) word.generated_tasks = null;
                        if (!word.structures) word.structures = [];
                    });

                    renderTable();
                    DOM.dataReviewSection.classList.remove('hidden');
                    DOM.uploadBtn.innerHTML = '<i class="fas fa-save mr-2"></i>Cập nhật Bộ Từ Vựng';
                    
                    const uploadSection = DOM.processFilesBtn.closest('.glass-panel');
                    uploadSection.style.opacity = '0.5';
                    uploadSection.style.pointerEvents = 'none';
                    uploadSection.title = 'Không thể nhập file CSV khi đang chỉnh sửa.';

                    DOM.modalContainer.querySelector('.modal.is-open')?.remove();

                } else {
                    showAlert(`Lỗi: Không tìm thấy bộ từ vựng với ID: ${testId}`, 'error');
                }
            } catch (error) {
                showAlert(`Lỗi khi tải dữ liệu: ${error.message}`, 'error', error.stack);
                console.error("Error loading test data:", error);
            }
        }
        
        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            onAuthStateChanged(auth, user => {
                if (user) {
                    DOM.loginScreen.classList.remove('is-open');
                    DOM.mainContent.style.display = 'block';
                    initializePage();
                } else {
                    DOM.loginScreen.classList.add('is-open');
                    DOM.mainContent.style.display = 'none';
                }
            });

            DOM.loginBtn.addEventListener('click', async () => {
                DOM.loginError.textContent = '';
                try { 
                    await signInWithEmailAndPassword(auth, DOM.emailInput.value, DOM.passwordInput.value); 
                } catch (e) { 
                    DOM.loginError.textContent = 'Email hoặc mật khẩu không đúng.'; 
                }
            });

            DOM.logoutBtn.addEventListener('click', () => signOut(auth));
            DOM.uploadBtn.addEventListener('click', uploadToFirebase);

            const handleFileUpload = (event, type) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (type === 'vocab') { 
                        vocabCsvText = e.target.result; 
                        DOM.vocabFileNameDisplay.textContent = file.name; 
                    } else { 
                        structuresCsvText = e.target.result; 
                        DOM.structuresFileNameDisplay.textContent = file.name; 
                    }
                };
                reader.readAsText(file);
            };

            DOM.vocabCsvUploadInput.addEventListener('change', (e) => handleFileUpload(e, 'vocab'));
            DOM.structuresCsvUploadInput.addEventListener('change', (e) => handleFileUpload(e, 'structures'));
            
            DOM.processFilesBtn.addEventListener('click', () => {
                if (!vocabCsvText) return showAlert("Vui lòng tải lên file CSV từ vựng.", 'error');
                parseAndStructureCSV(vocabCsvText, structuresCsvText || '');
                renderTable();
                DOM.dataReviewSection.classList.remove('hidden');
            });

            DOM.darkModeToggle.addEventListener('change', () => {
                document.body.classList.toggle('dark');
                const dot = DOM.darkModeToggle.nextElementSibling.nextElementSibling;
                dot.style.transform = DOM.darkModeToggle.checked ? 'translateX(100%)' : 'translateX(0)';
            });
            
            DOM.cefrSlider.addEventListener('input', () => DOM.cefrDisplay.textContent = getCefrLevelDescription());
            
            DOM.fetchAudioBtn.addEventListener('click', async () => {
                if (localWordList.length === 0) return showAlert("Chưa có dữ liệu.", 'error');
                const button = DOM.fetchAudioBtn;
                const originalHTML = button.innerHTML;
                button.disabled = true;
                for (let i = 0; i < localWordList.length; i++) {
                    const wordData = localWordList[i];
                    updateButtonState(button, true, '', `Đang tìm... (${i + 1}/${localWordList.length})`);
                    if (wordData.audioUrl || !wordData.word) continue;
                    try {
                        const response = await fetch(`${CLOUD_FUNCTION_URL}?word=${encodeURIComponent(wordData.word)}`);
                        if (!response.ok) throw new Error(`Server error`);
                        const result = await response.json();
                        if (result.success) wordData.audioUrl = result.audioUrl;
                    } catch (error) { console.error(`Lỗi với từ '${wordData.word}':`, error); }
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                renderTable();
                updateButtonState(button, false, originalHTML);
            });

            const handleAutomaticEnrichment = async (overwriteAll) => {
                const selectedRows = Array.from(document.querySelectorAll('.row-checkbox:checked'));
                const selectedWordIds = selectedRows.map(cb => parseInt(cb.dataset.wordId, 10));
                
                let wordsToEnrich = localWordList.filter(w => selectedWordIds.includes(w.id));
                if (wordsToEnrich.length === 0) {
                    return showAlert("Vui lòng chọn ít nhất một từ để làm giàu.", 'error');
                }
                
                if (!overwriteAll) {
                    const taskKeys = Object.keys(ALL_TASK_TYPES);
                    wordsToEnrich = wordsToEnrich.filter(w => taskKeys.some(type => !w.generated_tasks || !w.generated_tasks[type]));
                     if (wordsToEnrich.length === 0) {
                         return showAlert("Các từ đã chọn đã có đủ dữ liệu. Chọn 'Làm giàu (Ghi đè)' nếu muốn tạo lại.", 'info');
                    }
                }

                const button = DOM.enrichDataBtn;
                const originalHTML = button.innerHTML;
                updateButtonState(button, true, originalHTML);

                try {
                    for (let i = 0; i < wordsToEnrich.length; i += AI_BATCH_SIZE) {
                        const batch = wordsToEnrich.slice(i, i + AI_BATCH_SIZE);
                        updateButtonState(button, true, '', `Đang xử lý... (${i + batch.length}/${wordsToEnrich.length})`);
                        const prompt = getPromptForBatch(batch, overwriteAll);
                        const model = DOM.aiModelSelect.value;
                        const results = await callGeminiAPI(prompt, model);
                        processAiResults(results);
                    }
                } catch (error) {
                    showAlert(`Lỗi khi làm giàu dữ liệu: ${error.message}`, 'error');
                } finally {
                    updateButtonState(button, false, originalHTML);
                }
            };

            const handleManualEnrichment = (overwriteAll) => {
                const selectedRows = Array.from(document.querySelectorAll('.row-checkbox:checked'));
                const selectedWordIds = selectedRows.map(cb => parseInt(cb.dataset.wordId, 10));
                let wordsToEnrich = localWordList.filter(w => selectedWordIds.includes(w.id));
                if (wordsToEnrich.length === 0) return showAlert("Vui lòng chọn ít nhất một từ để làm giàu thủ công.", 'error');

                if (!overwriteAll) {
                    const taskKeys = Object.keys(ALL_TASK_TYPES);
                    wordsToEnrich = wordsToEnrich.filter(w => taskKeys.some(type => !w.generated_tasks || !w.generated_tasks[type]));
                     if (wordsToEnrich.length === 0) {
                         return showAlert("Các từ đã chọn đã có đủ dữ liệu. Chọn 'Làm giàu (Ghi đè)' nếu muốn tạo lại.", 'info');
                    }
                }
                
                DOM.manualPromptOutput.value = getPromptForBatch(wordsToEnrich, overwriteAll);
                DOM.manualPromptInput.value = '';
                DOM.manualPromptModal.classList.add('is-open');
            };

            DOM.enrichDataBtn.addEventListener('click', async () => {
                const selectedRows = Array.from(document.querySelectorAll('.row-checkbox:checked'));
                if (selectedRows.length === 0) {
                    return showAlert("Vui lòng chọn ít nhất một từ để làm giàu.", 'error');
                }
                
                const enrichmentType = await showChoiceModal(
                    "Chọn Phương thức", 
                    "Bạn muốn làm giàu những phần còn thiếu hay tạo lại toàn bộ?",
                    [
                        { label: "Làm giàu Lỗ hổng", value: "missing" },
                        { label: "Làm giàu Ghi đè", value: "all" }
                    ]
                );

                if (enrichmentType === 'cancel') return;
                const overwriteAll = enrichmentType === 'all';

                const executionType = await showChoiceModal(
                    "Chọn Cách thực hiện",
                    "Sử dụng AI tự động hay nhập thủ công?",
                    [
                        { label: "Tự động (AI)", value: "auto" },
                        { label: "Thủ công", value: "manual" }
                    ]
                );
                
                if (executionType === 'cancel') return;

                if (executionType === 'auto') {
                    handleAutomaticEnrichment(overwriteAll);
                } else if (executionType === 'manual') {
                    handleManualEnrichment(overwriteAll);
                }
            });

            // --- WORD EXPORT EVENT LISTENERS ---
            DOM.exportWordBtn.addEventListener('click', () => {
                if (localWordList.length === 0 || localWordList.every(w => !w.generated_tasks)) {
                    return showAlert("Không có dữ liệu bài tập để xuất. Vui lòng làm giàu dữ liệu trước.", 'error');
                }
                DOM.wordExportModal.classList.add('is-open');
                document.getElementById('export-main-title').value = DOM.testTitleInput.value || "ĐỀ KIỂM TRA TỪ VỰNG";
                document.getElementById('export-total-questions').value = Math.min(20, localWordList.filter(w => w.generated_tasks).length);
                initializeLevelConfig();
            });

            DOM.closeWordExportModalBtn.addEventListener('click', () => DOM.wordExportModal.classList.remove('is-open'));
            DOM.generateRandomTestBtn.addEventListener('click', generateAndDownloadRandomTests);
            DOM.generateFullExportBtn.addEventListener('click', exportAllQuestions);
            
            DOM.tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    DOM.tabs.forEach(t => t.classList.remove('active'));
                    DOM.tabContents.forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });

            DOM.closeManualModalBtn.addEventListener('click', () => DOM.manualPromptModal.classList.remove('is-open'));
            DOM.copyPromptBtn.addEventListener('click', () => {
                DOM.manualPromptOutput.select();
                document.execCommand('copy');
                showAlert("Đã sao chép Prompt!", 'success');
            });
            DOM.processManualResultBtn.addEventListener('click', () => {
                try {
                    const jsonText = DOM.manualPromptInput.value.trim().replace(/^```json\s*|```\s*$/g, '');
                    if (!jsonText) throw new Error("Vui lòng dán kết quả JSON.");
                    const results = JSON.parse(jsonText);
                    processAiResults(results);
                    DOM.manualPromptModal.classList.remove('is-open');
                } catch (error) {
                    showAlert(`Lỗi xử lý JSON: ${error.message}`, 'error');
                }
            });
            
            DOM.dataTableBody.addEventListener('blur', (e) => {
                const target = e.target;
                if (target.hasAttribute('contenteditable')) {
                    const wordIndex = parseInt(target.dataset.wordIndex, 10);
                    const path = target.dataset.path;
                    const newText = target.textContent;
                    if (isNaN(wordIndex) || !localWordList[wordIndex] || !path) return;
                    updateNestedObject(localWordList[wordIndex], path, newText);
                }
            }, true);

            DOM.selectAllCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                document.querySelectorAll('.row-checkbox').forEach(cb => cb.checked = isChecked);
            });
        }
        
        function initializeLevelConfig() {
            const container = DOM.exportLevelsContainer;
            container.innerHTML = ''; // Clear previous
            Object.keys(LEVEL_DEFINITIONS).forEach(level => {
                const div = document.createElement('div');
                div.className = 'level-config flex items-center gap-2';
                div.innerHTML = `<input type="checkbox" id="export-level-${level}" data-level="${level}" checked class="w-5 h-5"><label for="export-level-${level}" class="font-medium">${LEVEL_DEFINITIONS[level]}</label><input type="number" data-level="${level}" value="25" min="0" max="100" step="5" class="input-field !p-2 !w-20">`;
                container.appendChild(div);
            });

            const percentageInputs = container.querySelectorAll('input[type="number"]');
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            
            const updateTotal = () => {
                let total = 0;
                percentageInputs.forEach(input => { if (!input.disabled) total += Number(input.value); });
                DOM.exportTotalPercentage.textContent = total;
                if (total !== 100) {
                    DOM.exportTotalPercentage.classList.add('text-red-500');
                    DOM.exportValidationMessage.textContent = 'Tổng tỷ lệ phải bằng 100%.';
                } else {
                    DOM.exportTotalPercentage.classList.remove('text-red-500');
                    DOM.exportValidationMessage.textContent = '';
                }
            };

            checkboxes.forEach(cb => {
                cb.addEventListener('change', (e) => {
                    const level = e.target.dataset.level;
                    const input = container.querySelector(`input[type="number"][data-level="${level}"]`);
                    input.disabled = !e.target.checked;
                    updateTotal();
                });
            });
            percentageInputs.forEach(input => input.addEventListener('input', updateTotal));
            updateTotal();
        }

        // --- PAGE INITIALIZATION ---
        async function initializePage() {
            const urlParams = new URLSearchParams(window.location.search);
            const testIdToEdit = urlParams.get('edit');

            if (testIdToEdit) {
                await loadAndPopulateTestData(testIdToEdit);
            } else {
                DOM.pageTitle.textContent = "Trình Soạn Thảo Bộ Từ Vựng";
                DOM.uploadBtn.innerHTML = '<i class="fas fa-cloud-upload-alt mr-2"></i>Lưu Bộ Từ Vựng';
            }
        }

        // Start the application
        DOM.cefrDisplay.textContent = getCefrLevelDescription();
        setupEventListeners();

    </script>
</body>
</html>
