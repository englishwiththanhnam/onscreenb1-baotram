<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªçc T·ª´ V·ª±ng - L·ªô Tr√¨nh Th√≠ch ·ª®ng</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    
    <script type="module">
        import { Renderer, Camera, Transform, Program, Geometry, Mesh } from 'https://cdn.skypack.dev/ogl';
        window.OGL = { Renderer, Camera, Transform, Program, Geometry, Mesh };
    </script>

    <style>
        :root {
            --bg-dark: #0f172a;
            --text-light: #e2e8f0;
            --text-secondary: #94a3b8;
            --glass-bg: rgba(30, 41, 59, 0.5);
            --glass-border: rgba(255, 255, 255, 0.1);
            --primary-accent: #8b5cf6;
            --primary-accent-glow: rgba(139, 92, 246, 0.5);
            --correct-color: #22c55e;
            --incorrect-color: #ef4444;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: var(--bg-dark); 
            color: var(--text-light); 
            overflow-x: hidden; 
            overflow-y: auto;
        }
        
        .background-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; overflow: hidden; }
        #ogl-canvas-back { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .shape { position: absolute; border-radius: 50%; filter: blur(150px); opacity: 0.3; }
        .shape1 { width: 40vw; height: 40vw; max-width: 500px; max-height: 500px; background: #a855f7; top: -15%; left: -10%; animation: float 28s infinite alternate ease-in-out; }
        .shape2 { width: 35vw; height: 35vw; max-width: 450px; max-height: 450px; background: #22d3ee; bottom: -15%; right: -10%; animation: float 32s infinite alternate ease-in-out; }
        @keyframes float { from { transform: translateY(20px) rotate(0deg); } to { transform: translateY(-20px) rotate(15deg); } }

        .fade-in { animation: fadeIn 0.5s ease-in-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .glass-panel { background: var(--glass-bg); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border: 1px solid var(--glass-border); border-radius: 24px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .cta-btn {
            position: relative; overflow: hidden; display: inline-flex; align-items: center; justify-content: center; gap: 12px;
            background: linear-gradient(90deg, #8b5cf6, #6d28d9); font-family: 'Poppins', sans-serif; font-weight: 600; font-size: 16px;
            padding: 12px 24px; border-radius: 99px; border: none; cursor: pointer; text-decoration: none; color: rgba(255,255,255,0.9);
            box-shadow: 0 10px 30px -10px var(--primary-accent-glow); transition: all 0.3s ease;
        }
        .cta-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; }
        .cta-btn.secondary { background: transparent; border: 2px solid #5c5f89; box-shadow: none; color: #a2a6c3; }
        .cta-btn.danger { background: transparent; border: 2px solid var(--incorrect-color); color: var(--incorrect-color); }
        .progress-track { background: rgba(255, 255, 255, 0.1); border-radius: 9999px; height: 10px; overflow: hidden; border: 1px solid var(--glass-border); }
        .progress-fill { background: linear-gradient(90deg, #d8b4fe 0%, #a855f7 100%); height: 100%; transition: width 0.5s cubic-bezier(0.25, 1, 0.5, 1); }
        .answer-option { display: block; width: 100%; padding: 1rem; border-radius: 16px; text-align: left; font-weight: 500; background: transparent; border: 2px solid #5c5f89; color: #a2a6c3; transition: all 0.2s ease; }
        .answer-option:not(.disabled):hover { border-color: var(--primary-accent); background-color: rgba(139, 92, 246, 0.1); }
        .answer-option.disabled { cursor: not-allowed; opacity: 0.6; }
        .answer-option.selected.correct { border-color: var(--correct-color); background: rgba(34, 197, 94, 0.2); color: #bbf7d0; }
        .answer-option.selected.incorrect { border-color: var(--incorrect-color); background: rgba(239, 68, 68, 0.2); color: #fecaca; }
        .answer-option.correct-answer { border-color: var(--correct-color); background: rgba(34, 197, 94, 0.1); }
        .text-input-styled { background: rgba(55, 65, 81, 0.5); border: 1px solid var(--glass-border); border-radius: 12px; padding: 0.75rem 1rem; color: var(--text-light); caret-color: var(--primary-accent); }
        .text-input-styled:focus { outline: none; border-color: var(--primary-accent); box-shadow: 0 0 0 3px var(--primary-accent-glow); }
        .level-card { border: 2px solid var(--glass-border); text-align: center; transition: all 0.3s ease; }
        .level-card.locked { opacity: 0.5; filter: grayscale(80%); }
        .level-card.locked .cta-btn { pointer-events: none; }
        .level-card.passed { border-color: var(--correct-color); background: rgba(34, 197, 94, 0.1); }
        .level-card.active { border-color: var(--primary-accent); box-shadow: 0 0 20px var(--primary-accent-glow); transform: translateY(-5px); }
        .level-card.unlocked:not(.active):hover { border-color: var(--primary-accent); transform: translateY(-5px); }
        .report-actions { border-top: 1px solid var(--glass-border); margin-top: 1.5rem; padding-top: 1.5rem; display: flex; gap: 0.75rem; z-index: 10; }
        .report-btn { background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); color: var(--text-secondary); padding: 0.5rem 0.75rem; border-radius: 8px; font-size: 0.75rem; cursor: pointer; transition: all 0.2s ease; }
        .report-category-group label { display: block; padding: 0.75rem; border-radius: 12px; border: 1px solid var(--glass-border); background: rgba(0,0,0,0.2); cursor: pointer; transition: all 0.2s ease; }
        .report-category-group input:checked + label { background: var(--primary-accent); border-color: var(--primary-accent-glow); color: white; }
        .report-category-group input { display: none; }
        #report-comment-input { width: 100%; padding: 0.75rem; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(0,0,0,0.2); color: var(--text-light); margin-top: 1rem; resize: vertical; }
        
        /* Flashcard Styles */
        .flashcard { perspective: 1500px; }
        .flashcard-inner { position: relative; width: 100%; height: 100%; transition: transform 0.7s; transform-style: preserve-3d; }
        .flashcard.is-flipped .flashcard-inner { transform: rotateY(180deg); }
        .flashcard-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; -webkit-backface-visibility: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center; background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 24px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .flashcard-back { transform: rotateY(180deg); }
        .flashcard-word { font-family: 'Poppins', sans-serif; font-size: clamp(2rem, 8vw, 4rem); font-weight: 700; }
        .flashcard-pronunciation { font-family: 'Inter', sans-serif; color: var(--text-secondary); margin-top: 0.5rem; }
        .flashcard-meaning { font-family: 'Poppins', sans-serif; font-size: clamp(1.5rem, 6vw, 2.5rem); font-weight: 600; }
        .flashcard-example { font-style: italic; color: var(--text-secondary); margin-top: 1.5rem; }
        .audio-btn { position: absolute; top: 1.5rem; right: 1.5rem; width: 44px; height: 44px; border-radius: 50%; background-color: rgba(255, 255, 255, 0.1); color: var(--text-secondary); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; z-index: 10; }

        /* Guide Modal Styles */
        .guide-section h3 { font-family: 'Poppins', sans-serif; font-size: 1.5rem; font-weight: 700; color: var(--primary-accent); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid var(--primary-accent); }
        .guide-rule { background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 12px; border-left: 4px solid var(--primary-accent); }
        .task-example-card { background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); border-radius: 16px; padding: 1.5rem; }
    </style>
</head>
<body>
    <div class="background-layer">
        <div class="shape shape1"></div>
        <div class="shape shape2"></div>
        <div id="ogl-canvas-back"></div>
    </div>
    
    <div id="loader-overlay" class="fixed inset-0 bg-slate-900/80 backdrop-blur-sm flex flex-col items-center justify-center z-50">
        <div class="w-16 h-16 border-4 border-t-violet-500 border-gray-600 rounded-full animate-spin"></div>
        <p id="loader-text" class="text-lg font-semibold text-white mt-4">ƒêang t·∫£i d·ªØ li·ªáu...</p>
    </div>
    <div id="modal-container"></div>
    
    <div id="app-container" class="max-w-7xl mx-auto p-4 sm:p-8">
        <header id="app-header" class="mb-8"></header>
        <main id="app-main"></main>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getFirestore, doc, getDoc, updateDoc, runTransaction, arrayUnion, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";

        // Background Animation
        if (window.OGL) {
            const { Renderer, Camera, Program, Geometry, Mesh, Transform } = window.OGL;
            const container = document.getElementById('ogl-canvas-back');
            if (container) {
                const renderer = new Renderer({ dpr: 2, alpha: true });
                const gl = renderer.gl;
                container.appendChild(gl.canvas);
                const camera = new Camera(gl, { fov: 15, near: 1, far: 100 });
                camera.position.set(0, 0, 25);
                const scene = new Transform();
                const program = new Program(gl, {
                    vertex: `attribute vec3 position;attribute vec4 random;attribute vec3 color;uniform mat4 modelMatrix;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform float uTime;uniform float uSpread;uniform float uBaseSize;varying vec4 vRandom;varying vec3 vColor;void main(){vRandom=random;vColor=color;vec3 pos=position*uSpread;vec4 mPos=modelMatrix*vec4(pos,1.);float t=uTime*.1;mPos.x+=sin(t*random.z+6.28*random.w)*mix(.1,1.5,random.x);mPos.y+=sin(t*random.y+6.28*random.x)*mix(.1,1.5,random.w);mPos.z+=cos(t*random.w+6.28*random.y)*mix(.1,1.5,random.z);vec4 mvPos=viewMatrix*mPos;gl_PointSize=uBaseSize/-mvPos.z;gl_Position=projectionMatrix*mvPos;}`,
                    fragment: `precision highp float;varying vec3 vColor;void main(){vec2 uv=gl_PointCoord.xy;float d=length(uv-vec2(.5));float glow=smoothstep(.5,0.,d)*.3;float core=smoothstep(.2,.18,d);float alpha=max(core,glow);if(alpha<.01)discard;vec3 finalColor=vColor+vColor*pow(glow,2.)*2.;gl_FragColor=vec4(finalColor,alpha);}`,
                    uniforms: { uTime: { value: 0 }, uSpread: { value: 10 }, uBaseSize: { value: 350 } },
                    transparent: true, depthTest: false
                });
                const count = 200;
                const positions = new Float32Array(count * 3);
                const randoms = new Float32Array(count * 4);
                const colors = new Float32Array(count * 3);
                const palette = ['#a855f7', '#8b5cf6', '#22d3ee', '#f59e0b'];
                const hexToRgb = (h) => { const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h); return r ? [parseInt(r[1], 16)/255, parseInt(r[2], 16)/255, parseInt(r[3], 16)/255] : [0,0,0]; };
                for (let i = 0; i < count; i++) {
                    const z = (Math.random() - 0.5) * 30;
                    positions.set([(Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, z], i * 3);
                    randoms.set([Math.random(), Math.random(), Math.random(), Math.random()], i * 4);
                    colors.set(hexToRgb(palette[Math.floor(Math.random() * palette.length)]), i * 3);
                }
                const geometry = new Geometry(gl, { position: { size: 3, data: positions }, random: { size: 4, data: randoms }, color: { size: 3, data: colors } });
                const particles = new Mesh(gl, { mode: gl.POINTS, geometry, program });
                particles.setParent(scene);
                function resize() { renderer.setSize(window.innerWidth, window.innerHeight); camera.perspective({ aspect: window.innerWidth / window.innerHeight }); }
                window.addEventListener("resize", resize, false);
                resize();
                requestAnimationFrame(update);
                function update(t) { requestAnimationFrame(update); program.uniforms.uTime.value = t * 0.001; renderer.render({ scene, camera }); }
            }
        }

        const App = {
            state: {},
            DOM: {},
            db: null,

            CONFIG: {
                LEVELS: {
                    1: { name: "N·ªÅn t·∫£ng", tasks: ['MeaningMCQ', 'IPAFill', 'AudioListening'] },
                    2: { name: "Ng·ªØ ph√°p & C·∫•u tr√∫c", tasks: ['WordFamilyMCQ', 'SentenceUnscramble', 'ErrorCorrection', 'TripledSentence'] },
                    3: { name: "Ng·ªØ nghƒ©a & Ng·ªØ d·ª•ng", tasks: ['BestFitReplacement', 'BestParaphrase', 'AntonymMCQ'] },
                    4: { name: "T∆∞ duy Ph·∫£n bi·ªán", tasks: ['InferenceFromScenario', 'MainIdea', 'ParagraphCompletion', 'ArgumentStrengthening', 'ArgumentWeakening', 'TonePurposeAnalysis', 'SentenceRoleAnalysis'] }
                },
                RULES: {
                    UNLOCK_THRESHOLD: 0.9,
                    PROFICIENCY_TEST_UNLOCK: { 2: 0.8, 3: 0.9 },
                    PROFICIENCY_TESTS: {
                        1: { passMark: 0.9, maxAttempts: 3 },
                        2: { passMark: 0.9, maxAttempts: 3 },
                        3: { passMark: 0.9, maxAttempts: 3 },
                    },
                    FINAL_TEST_UNLOCK_THRESHOLD: 0.8,
                    PRACTICE_SESSION_LENGTH: 10,
                }
            },
            
            EXERCISE_INFO: {
                'MeaningMCQ': { name: 'Meaning MCQ', icon: 'üí°', desc: 'Ch·ªçn ƒë√∫ng nghƒ©a ti·∫øng Vi·ªát c·ªßa t·ª´ ƒë√£ cho.' },
                'WordFamilyMCQ': { name: 'Word Family', icon: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', desc: 'Ch·ªçn d·∫°ng t·ª´ ƒë√∫ng (danh t·ª´, ƒë·ªông t·ª´, t√≠nh t·ª´...) ƒë·ªÉ ho√†n th√†nh c√¢u.' },
                'SentenceUnscramble': { name: 'Sentence Unscramble', icon: 'üîÑ', desc: 'S·∫Øp x·∫øp c√°c t·ª´ b·ªã x√°o tr·ªôn th√†nh m·ªôt c√¢u ho√†n ch·ªânh.' },
                'ErrorCorrection': { name: 'Error Correction', icon: '‚úçÔ∏è', desc: 'ƒê·ªçc v√† s·ª≠a l·∫°i l·ªói sai trong c√¢u.' },
                'IPAFill': { name: 'IPA Fill', icon: 'üó£Ô∏è', desc: 'Ch·ªçn ƒë√∫ng nguy√™n √¢m ƒë·ªÉ ho√†n th√†nh phi√™n √¢m IPA c·ªßa t·ª´.' },
                'BestFitReplacement': { name: 'Best-fit Replacement', icon: 'üéØ', desc: 'Ch·ªçn t·ª´ ƒë·ªìng nghƒ©a ph√π h·ª£p nh·∫•t ƒë·ªÉ thay th·∫ø t·ª´ ƒë∆∞·ª£c g·∫°ch ch√¢n.' },
                'InferenceFromScenario': { name: 'Inference from Scenario', icon: 'üß†', desc: 'ƒê·ªçc m·ªôt t√¨nh hu·ªëng ng·∫Øn v√† tr·∫£ l·ªùi c√¢u h·ªèi suy lu·∫≠n v·ªÅ n√≥.' },
                'BestParaphrase': { name: 'Best Paraphrase', icon: 'üìë', desc: 'Ch·ªçn c√¢u di·ªÖn gi·∫£i l·∫°i ƒë√∫ng nh·∫•t √Ω c·ªßa c√¢u g·ªëc.' },
                'AudioListening': { name: 'Listening & Typing', icon: 'üéß', desc: 'Nghe v√† g√µ l·∫°i ch√≠nh x√°c t·ª´ b·∫°n nghe ƒë∆∞·ª£c.' },
                'AntonymMCQ': { name: 'Antonym Challenge', icon: '‚ÜîÔ∏è', desc: 'Ch·ªçn t·ª´ c√≥ nghƒ©a tr√°i ng∆∞·ª£c v·ªõi t·ª´ cho tr∆∞·ªõc.' },
                'TripledSentence': { name: 'Tripled Sentence', icon: 'üß©', desc: 'M·ªôt t·ª´ b·ªã thi·∫øu trong c·∫£ ba c√¢u. H√£y t√¨m ra t·ª´ ƒë√≥.' },
                'MainIdea': { name: 'Find the Main Idea', icon: 'üéØ', desc: 'ƒê·ªçc m·ªôt ƒëo·∫°n vƒÉn ng·∫Øn v√† ch·ªçn c√¢u di·ªÖn ƒë·∫°t ƒë√∫ng nh·∫•t √Ω ch√≠nh.' },
                'ParagraphCompletion': { name: 'Find the Conclusion', icon: 'üèÅ', desc: 'Ch·ªçn c√¢u ph√π h·ª£p nh·∫•t ƒë·ªÉ k·∫øt th√∫c ƒëo·∫°n vƒÉn.' },
                'ArgumentStrengthening': { name: 'Strengthen the Argument', icon: 'üëç', desc: 'Ch·ªçn lu·∫≠n ƒëi·ªÉm c·ªßng c·ªë m·∫°nh nh·∫•t cho l·∫≠p lu·∫≠n c·ªßa t√°c gi·∫£.' },
                'ArgumentWeakening': { name: 'Weaken the Argument', icon: 'üëé', desc: 'Ch·ªçn lu·∫≠n ƒëi·ªÉm l√†m suy y·∫øu nh·∫•t l·∫≠p lu·∫≠n c·ªßa t√°c gi·∫£.' },
                'TonePurposeAnalysis': { name: 'Tone/Purpose Identification', icon: 'üé≠', desc: 'X√°c ƒë·ªãnh gi·ªçng vƒÉn (th√°i ƒë·ªô) ho·∫∑c m·ª•c ƒë√≠ch vi·∫øt c·ªßa t√°c gi·∫£.' },
                'SentenceRoleAnalysis': { name: 'Sentence Role Analysis', icon: 'üîç', desc: 'Ph√¢n t√≠ch v√† x√°c ƒë·ªãnh vai tr√≤ c·ªßa m·ªôt c√¢u ƒë∆∞·ª£c ƒë√°nh d·∫•u trong l·∫≠p lu·∫≠n.' },
            },

            async init() {
                const firebaseConfig = {
                    apiKey: "AIzaSyBUet6ZsBTwJG_gTKM2bGFG1AKD3t0hV20",
                    authDomain: "b1-baotram.firebaseapp.com",
                    projectId: "b1-baotram",
                    storageBucket: "b1-baotram.appspot.com",
                    messagingSenderId: "948701163187",
                    appId: "1:948701163187:web:043f2d381d63e741114ac6",
                    measurementId: "G-33NHT07JHE"
                };
                
                const firebaseApp = initializeApp(firebaseConfig);
                this.db = getFirestore(firebaseApp);

                this.DOM = {
                    loader: document.getElementById('loader-overlay'),
                    loaderText: document.getElementById('loader-text'),
                    container: document.getElementById('app-container'),
                    header: document.getElementById('app-header'),
                    main: document.getElementById('app-main'),
                    modal: document.getElementById('modal-container'),
                };
                
                this.resetState();
                
                const params = new URLSearchParams(window.location.search);
                const submissionId = params.get('submission_id');

                if (!submissionId) {
                    this.showModal("L·ªói", "Kh√¥ng t√¨m th·∫•y m√£ b√†i l√†m (Submission ID).");
                    this.DOM.loader.classList.add('hidden');
                    return;
                }
                
                this.state.submissionId = submissionId;
                await this.loadData(submissionId);

                window.addEventListener('beforeunload', (e) => {
                    if (this.state.submissionId) {
                        // This is a failsafe, but async operations are not guaranteed here.
                        // Main saving logic is now tied to explicit navigation.
                        this.updateFirestoreProgress(); 
                    }
                });
            },
            
            resetState() {
                this.state = {
                    submissionId: null, studentId: '', studentName: '', testData: {}, wordList: [],
                    isSubmitting: false,
                    userProgress: {
                        levels: {
                            1: { status: 'locked', completedTasks: new Set(), totalTasks: 0, testAttempts: 0 },
                            2: { status: 'locked', completedTasks: new Set(), totalTasks: 0, testAttempts: 0 },
                            3: { status: 'locked', completedTasks: new Set(), totalTasks: 0, testAttempts: 0 },
                            4: { status: 'locked', completedTasks: new Set(), totalTasks: 0, testAttempts: 0 },
                        },
                        totalCompletedTasks: 0,
                        totalTasksInTest: 0,
                        finalTestTaken: false,
                        finalTestScore: null,
                    },
                    currentPractice: { level: null, items: [], index: 0, isTest: false, correctAnswer: null, score: 0, sessionCorrectUIDs: new Set(), sessionIncorrectUIDs: new Set() },
                    currentFlashcard: { items: [], index: 0 }
                };
            },

            async loadData(submissionId) {
                try {
                    const submissionRef = doc(this.db, 'submissions', submissionId);
                    const submissionSnap = await getDoc(submissionRef);
                    if (!submissionSnap.exists()) throw new Error("M√£ b√†i l√†m kh√¥ng h·ª£p l·ªá.");

                    let submissionData = submissionSnap.data();
                    this.state.studentId = submissionData.studentId;
                    this.state.testData = submissionData.testSnapshot;
                    this.state.wordList = this.state.testData.wordList || [];

                    const userDoc = await getDoc(doc(this.db, "users", this.state.studentId));
                    this.state.studentName = userDoc.exists() ? userDoc.data().displayName : "Kh√¥ng r√µ";

                    let totalTasks = 0;
                    Object.keys(this.CONFIG.LEVELS).forEach(level => {
                        const tasksForLevel = this.CONFIG.LEVELS[level].tasks;
                        let count = 0;
                        this.state.wordList.forEach(word => {
                            if (word.generated_tasks) {
                                tasksForLevel.forEach(taskType => {
                                    if (this.isTaskAvailable(word, taskType)) count++;
                                });
                            }
                        });
                        this.state.userProgress.levels[level].totalTasks = count;
                        totalTasks += count;
                    });
                    this.state.userProgress.totalTasksInTest = totalTasks;

                    if (submissionData.adaptiveProgressV2) {
                        const progress = submissionData.adaptiveProgressV2;
                        if (!progress.levels) progress.levels = this.state.userProgress.levels;
                        
                        Object.keys(this.CONFIG.LEVELS).forEach(level => {
                           if (!progress.levels[level]) {
                               progress.levels[level] = this.state.userProgress.levels[level];
                           }
                           progress.levels[level].completedTasks = new Set(progress.levels[level].completedTasks || []);
                           progress.levels[level].totalTasks = this.state.userProgress.levels[level].totalTasks;
                        });
                        this.state.userProgress = { ...this.state.userProgress, ...progress };
                    } else {
                        this.state.userProgress.levels[1].status = 'unlocked';
                    }
                    
                    this.state.userProgress.totalCompletedTasks = this.calculateTotalCompletedTasks();

                    this.DOM.loader.classList.add('hidden');
                    this.DOM.container.classList.remove('hidden');
                    
                    this.renderHeader();
                    this.renderDashboard();

                } catch (error) {
                    console.error("Load data error:", error);
                    this.DOM.loader.classList.add('hidden');
                    this.showModal("L·ªói", "Kh√¥ng th·ªÉ t·∫£i phi√™n l√†m b√†i: " + error.message);
                }
            },
            
            isTaskAvailable(word, taskType) {
                const tasks = word.generated_tasks;
                if (!tasks) return false;
                switch (taskType) {
                    case 'MeaningMCQ': return tasks.meaning_mcq?.distractors_vi?.length >= 3;
                    case 'WordFamilyMCQ': return tasks.word_family_mcq?.distractors?.length >= 3;
                    case 'SentenceUnscramble': return !!tasks.sentence_unscramble?.correct_sentence;
                    case 'ErrorCorrection': return !!tasks.error_correction?.incorrect_sentence;
                    case 'IPAFill': return tasks.ipa_fill?.distractors?.length >= 3;
                    case 'BestFitReplacement': return tasks.best_fit_replacement?.distractors?.length >= 3;
                    case 'InferenceFromScenario': return tasks.inference_from_scenario?.distractors?.length >= 3;
                    case 'BestParaphrase': return tasks.best_paraphrase?.options?.length > 1;
                    case 'AudioListening': return !!word.audioUrl;
                    case 'AntonymMCQ': return tasks.antonym_mcq?.distractors?.length >= 3;
                    case 'TripledSentence': return tasks.tripled_sentence?.examples?.length >= 1;
                    case 'MainIdea': return tasks.main_idea?.distractors?.length >= 3;
                    case 'ParagraphCompletion': return tasks.paragraph_completion?.distractors?.length >= 3;
                    case 'ArgumentStrengthening': return tasks.argument_strengthening?.distractors?.length >= 3;
                    case 'ArgumentWeakening': return tasks.argument_weakening?.distractors?.length >= 3;
                    case 'TonePurposeAnalysis': return tasks.tone_purpose_analysis?.distractors?.length >= 3;
                    case 'SentenceRoleAnalysis': return tasks.sentence_role_analysis?.distractors?.length >= 3;
                    default: return false;
                }
            },

            async updateFirestoreProgress() {
                if (!this.state.submissionId) return;
                const progressToSave = JSON.parse(JSON.stringify(this.state.userProgress));
                Object.keys(progressToSave.levels).forEach(level => {
                    if (progressToSave.levels[level]?.completedTasks) {
                       progressToSave.levels[level].completedTasks = Array.from(this.state.userProgress.levels[level].completedTasks);
                    }
                });
                try {
                    const submissionRef = doc(this.db, 'submissions', this.state.submissionId);
                    await updateDoc(submissionRef, { adaptiveProgressV2: progressToSave });
                } catch (error) {
                    console.error("L·ªói khi ƒë·ªìng b·ªô ti·∫øn tr√¨nh:", error);
                }
            },

            calculateTotalCompletedTasks() {
                let count = 0;
                Object.values(this.state.userProgress.levels).forEach(levelData => {
                    if (levelData.status === 'passed') {
                        count += levelData.totalTasks;
                    } else if (levelData.completedTasks) {
                        count += levelData.completedTasks.size;
                    }
                });
                return count;
            },

            renderHeader(showBackButton = false) {
                this.state.userProgress.totalCompletedTasks = this.calculateTotalCompletedTasks();
                const { totalCompletedTasks, totalTasksInTest } = this.state.userProgress;
                const overallProgress = totalTasksInTest > 0 ? (totalCompletedTasks / totalTasksInTest * 100) : 0;
                
                const backButtonHTML = showBackButton ? `<a href="student-dashboard.html" id="header-back-btn" class="cta-btn secondary !py-2 !px-4"><i class="fas fa-arrow-left mr-2"></i> Dashboard ch√≠nh</a>` : '';

                this.DOM.header.innerHTML = `
                    <div class="glass-panel p-4 flex flex-wrap justify-between items-center gap-4">
                        <div>
                            <h1 class="text-2xl font-bold font-poppins">${this.state.testData.title || 'L·ªô tr√¨nh h·ªçc t·∫≠p'}</h1>
                            <p class="text-sm text-text-secondary">H·ªçc sinh: <span class="font-medium text-text-light">${this.state.studentName}</span></p>
                        </div>
                        <div class="flex items-center gap-4">
                            ${backButtonHTML}
                            <div class="w-full sm:w-auto flex-grow sm:flex-grow-0 max-w-xs">
                                <p class="text-sm text-center font-medium mb-1">Ti·∫øn ƒë·ªô t·ªïng qu√°t: ${overallProgress.toFixed(1)}%</p>
                                <div class="progress-track"><div class="progress-fill" style="width: ${overallProgress.toFixed(1)}%;"></div></div>
                            </div>
                        </div>
                    </div>`;
                
                document.getElementById('header-back-btn')?.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const btn = e.currentTarget;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> ƒêang l∆∞u...';
                    btn.disabled = true;
                    await this.updateFirestoreProgress();
                    window.location.href = btn.href;
                });
            },

            renderDashboard() {
                this.DOM.main.innerHTML = `
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 fade-in">
                        <aside class="lg:col-span-1 space-y-6">
                            <div class="glass-panel p-6">
                                <h2 class="text-xl font-bold font-poppins mb-4">üìö B·∫Øt ƒë·∫ßu</h2>
                                <div class="space-y-3">
                                    <button id="show-guide-btn" class="cta-btn secondary w-full !rounded-lg"><i class="fas fa-book-open mr-2"></i>Xem H∆∞·ªõng D·∫´n & Quy T·∫Øc</button>
                                    <button data-flashcard-type="word" class="cta-btn secondary w-full !rounded-lg"><i class="fas fa-clone mr-2"></i>Flashcard T·ª´ V·ª±ng</button>
                                    <button data-flashcard-type="structure" class="cta-btn secondary w-full !rounded-lg" disabled><i class="fas fa-sitemap mr-2"></i>Flashcard C·∫•u Tr√∫c</button>
                                </div>
                            </div>
                        </aside>
                        <main class="lg:col-span-2 space-y-6">
                            <div class="glass-panel p-6 sm:p-8">
                                <h2 class="text-2xl font-bold font-poppins mb-6">üèãÔ∏è‚Äç‚ôÄÔ∏è L·ªô Tr√¨nh Luy·ªán T·∫≠p</h2>
                                <div id="levels-container" class="grid grid-cols-1 sm:grid-cols-2 gap-6"></div>
                            </div>
                            <div id="final-test-container" class="glass-panel p-8 text-center"></div>
                        </main>
                    </div>
                `;
                this.renderLevelCards();
                this.renderFinalTestSection();
                
                document.getElementById('show-guide-btn').addEventListener('click', () => this.renderGuideModal());
                this.DOM.main.querySelectorAll('button[data-flashcard-type]').forEach(btn => {
                    btn.addEventListener('click', (e) => this.startFlashcardSession(e.currentTarget.dataset.flashcardType));
                });
            },
            
            renderLevelCards() {
                const container = document.getElementById('levels-container');
                if (!container) return;
                container.innerHTML = Object.keys(this.CONFIG.LEVELS).map(levelKey => {
                    const levelNum = parseInt(levelKey);
                    const levelConfig = this.CONFIG.LEVELS[levelNum];
                    const progress = this.state.userProgress.levels[levelNum];
                    
                    let statusClass = progress.status;
                    let buttonText = 'Luy·ªán t·∫≠p';
                    let buttonDisabled = true;
                    let icon = 'fa-lock';
                    let testButtonHTML = '';
                    
                    const percent = progress.totalTasks > 0 ? (progress.completedTasks.size / progress.totalTasks) : 0;

                    if (progress.status === 'passed') {
                        buttonText = 'ƒê√£ qua';
                        icon = 'fa-check-circle text-correct-color';
                        buttonDisabled = true;
                    } else if (progress.status === 'unlocked') {
                        statusClass = 'unlocked';
                        buttonDisabled = false;
                        icon = 'fa-play-circle';
                        
                        const testConfig = this.CONFIG.RULES.PROFICIENCY_TESTS[levelNum];
                        const testUnlockThreshold = this.CONFIG.RULES.PROFICIENCY_TEST_UNLOCK[levelNum];

                        let canTakeTest = false;
                        if (levelNum === 1) {
                            canTakeTest = true;
                        } else if (testUnlockThreshold && percent >= testUnlockThreshold) {
                            canTakeTest = true;
                        }

                        if (testConfig && canTakeTest && progress.testAttempts < testConfig.maxAttempts) {
                            testButtonHTML = `<button data-test-level="${levelNum}" class="cta-btn w-full !rounded-lg mt-3 !text-sm !py-2">Ki·ªÉm tra v∆∞·ª£t c·∫•p (${progress.testAttempts}/${testConfig.maxAttempts})</button>`;
                        }
                    }
                    
                    return `
                        <div id="level-card-${levelNum}" class="level-card p-6 rounded-2xl ${statusClass}">
                            <div class="flex justify-between items-start mb-4">
                                <h3 class="font-bold text-2xl font-poppins">Level ${levelNum}</h3>
                                <i class="fas ${icon} text-2xl"></i>
                            </div>
                            <p class="text-sm text-text-secondary mb-4 text-left">${levelConfig.name}</p>
                            <div class="progress-track mb-4"><div class="progress-fill" style="width: ${(percent * 100).toFixed(0)}%;"></div></div>
                            <button data-level="${levelNum}" class="cta-btn secondary w-full !rounded-lg" ${buttonDisabled}>${buttonText}</button>
                            ${testButtonHTML}
                        </div>
                    `;
                }).join('');

                container.addEventListener('click', e => {
                    const practiceButton = e.target.closest('button[data-level]');
                    const testButton = e.target.closest('button[data-test-level]');
                    if (practiceButton && !practiceButton.disabled) {
                        this.startPractice(parseInt(practiceButton.dataset.level));
                    }
                    if (testButton && !testButton.disabled) {
                        this.runProficiencyTest(parseInt(testButton.dataset.testLevel));
                    }
                });
            },

            renderFinalTestSection() {
                const container = document.getElementById('final-test-container');
                if (!container) return;
                const totalCompleted = this.calculateTotalCompletedTasks();
                const { totalTasksInTest, finalTestTaken, finalTestScore } = this.state.userProgress;
                const overallProgress = totalTasksInTest > 0 ? (totalCompleted / totalTasksInTest) : 0;
                const isEligible = overallProgress >= this.CONFIG.RULES.FINAL_TEST_UNLOCK_THRESHOLD;

                if (isEligible) {
                    container.innerHTML = `
                        <h3 class="text-xl font-bold font-poppins mb-4">B√†i Ki·ªÉm Tra Cu·ªëi K·ª≥</h3>
                        <p class="text-text-secondary mb-6">B·∫°n ƒë√£ ƒë·ªß ƒëi·ªÅu ki·ªán. H√£y b·∫Øt ƒë·∫ßu b√†i ki·ªÉm tra cu·ªëi c√πng ƒë·ªÉ ho√†n t·∫•t!</p>
                        <button id="start-final-test-btn" class="cta-btn danger w-full max-w-xs mx-auto" ${finalTestTaken ? 'disabled' : ''}>
                            <i class="fas fa-graduation-cap mr-2"></i>
                            ${finalTestTaken ? `ƒê√£ l√†m (ƒêi·ªÉm: ${finalTestScore}%)` : 'B·∫Øt ƒë·∫ßu KT Cu·ªëi K·ª≥'}
                        </button>
                    `;
                    container.querySelector('#start-final-test-btn')?.addEventListener('click', () => this.startFinalTest());
                } else {
                    container.innerHTML = `<p class="text-text-secondary"><i class="fas fa-lock mr-2"></i>Ho√†n th√†nh ${(this.CONFIG.RULES.FINAL_TEST_UNLOCK_THRESHOLD * 100)}% ti·∫øn ƒë·ªô t·ªïng qu√°t ƒë·ªÉ m·ªü kh√≥a.</p>`;
                }
            },
            
            async checkLevelUp(level) {
                const progress = this.state.userProgress.levels[level];
                const nextLevelKey = level + 1;
                const nextLevelProgress = this.state.userProgress.levels[nextLevelKey];

                if (!nextLevelProgress || nextLevelProgress.status !== 'locked') return;

                const percent = progress.totalTasks > 0 ? (progress.completedTasks.size / progress.totalTasks) : 0;

                if (percent >= this.CONFIG.RULES.UNLOCK_THRESHOLD) {
                    nextLevelProgress.status = 'unlocked';
                    await this.updateFirestoreProgress();
                    this.showModal(`üéâ M·ªü kh√≥a Level ${nextLevelKey}!`, `Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh ƒë·ªß b√†i t·∫≠p ƒë·ªÉ m·ªü kh√≥a level ti·∫øp theo.`, false, () => {
                        this.renderLevelCards();
                    }, null, 'Tuy·ªát v·ªùi!');
                }
            },

            startPractice(level) {
                this.renderHeader(true);
                const levelProgress = this.state.userProgress.levels[level];
                
                const allLevelTasks = this.getAllTasksForLevel(level);
                // Prioritize uncompleted tasks
                const uncompletedTasks = this.shuffleArray(allLevelTasks.filter(task => !levelProgress.completedTasks.has(task.taskUID)));
                
                let practicePool = [];

                if (uncompletedTasks.length > 0) {
                    practicePool.push(...uncompletedTasks);
                }
                
                // If not enough uncompleted tasks, fill with completed ones for review
                if (practicePool.length < this.CONFIG.RULES.PRACTICE_SESSION_LENGTH) {
                    const completedTasks = this.shuffleArray(allLevelTasks.filter(task => levelProgress.completedTasks.has(task.taskUID)));
                    const needed = this.CONFIG.RULES.PRACTICE_SESSION_LENGTH - practicePool.length;
                    practicePool.push(...completedTasks.slice(0, needed));
                }

                if (practicePool.length === 0) {
                    this.showModal("Ho√†n th√†nh!", "B·∫°n ƒë√£ l√†m h·∫øt c√°c b√†i t·∫≠p cho level n√†y. H√£y th·ª≠ l√†m b√†i ki·ªÉm tra v∆∞·ª£t c·∫•p n·∫øu c√≥, ho·∫∑c quay l·∫°i sau.", false, () => {
                        this.renderDashboard();
                        this.renderHeader(false);
                    });
                    return;
                }

                this.state.currentPractice = {
                    level: level,
                    items: practicePool.slice(0, this.CONFIG.RULES.PRACTICE_SESSION_LENGTH),
                    index: 0,
                    isTest: false,
                    score: 0,
                    correctAnswer: null,
                    sessionCorrectUIDs: new Set(),
                    sessionIncorrectUIDs: new Set()
                };
                this.renderPracticeView();
            },

            async runProficiencyTest(levelToTest) {
                this.renderHeader(true);
                const progress = this.state.userProgress.levels[levelToTest];
                const testConfig = this.CONFIG.RULES.PROFICIENCY_TESTS[levelToTest];
                if (progress.testAttempts >= testConfig.maxAttempts) {
                    this.showModal("Th√¥ng b√°o", "B·∫°n ƒë√£ h·∫øt s·ªë l·∫ßn l√†m b√†i ki·ªÉm tra cho level n√†y.");
                    return;
                }
                
                const allLevelTasks = this.getAllTasksForLevel(levelToTest);

                if (allLevelTasks.length === 0) {
                    this.showModal("L·ªói", "Kh√¥ng c√≥ c√¢u h·ªèi n√†o cho b√†i ki·ªÉm tra n√†y.");
                    return;
                }

                const numQuestions = Math.min(allLevelTasks.length, Math.max(10, Math.ceil(allLevelTasks.length * 0.25)));
                this.state.currentPractice = {
                    items: this.shuffleArray(allLevelTasks).slice(0, numQuestions),
                    level: levelToTest,
                    index: 0,
                    isTest: true,
                    score: 0,
                    correctAnswer: null
                };
                
                progress.testAttempts++;
                await this.updateFirestoreProgress();
                this.renderPracticeView();
            },

            startFinalTest() {
                this.renderHeader(true);
                let allTasks = [];
                Object.keys(this.CONFIG.LEVELS).forEach(level => {
                    allTasks.push(...this.getAllTasksForLevel(level));
                });

                if (allTasks.length === 0) {
                    this.showModal("L·ªói", "Kh√¥ng c√≥ c√¢u h·ªèi n√†o cho b√†i ki·ªÉm tra cu·ªëi k·ª≥.");
                    return;
                }

                this.state.currentPractice = {
                    level: "Final",
                    items: this.shuffleArray(allTasks).slice(0, 50), // Limit final test to 50 questions
                    index: 0,
                    isTest: true,
                    score: 0,
                    correctAnswer: null
                };
                this.renderPracticeView();
            },

            renderPracticeView() {
                const { items, index, level, isTest } = this.state.currentPractice;
                const total = items.length;
                
                if (index >= total) {
                    if (isTest) {
                        level === "Final" ? this.renderFinalTestSummary() : this.renderTestSummary();
                    } else {
                        this.renderSessionSummary();
                    }
                    return;
                }
                
                const currentItem = items[index];
                const renderFunction = this[`get${currentItem.exerciseType}HTML`];
                
                const title = isTest ? `Ki·ªÉm tra ${level === "Final" ? "Cu·ªëi k·ª≥" : `Level ${level}`}` : `Level ${level} - Luy·ªán t·∫≠p`;

                this.DOM.main.innerHTML = `
                    <div class="glass-panel p-6 sm:p-8 fade-in">
                        <div class="flex justify-between items-center mb-6">
                            <h2 class="font-bold text-primary-accent">${title}</h2>
                            <div class="flex items-center gap-4">
                                <p class="text-sm font-medium text-text-secondary">C√¢u ${index + 1} / ${total}</p>
                                <button id="exit-practice-btn" class="text-sm font-semibold text-text-secondary hover:text-incorrect-color transition-colors"><i class="fas fa-times mr-1"></i> Tho√°t</button>
                            </div>
                        </div>
                        <div id="question-container" class="min-h-[300px]">
                            ${renderFunction ? renderFunction.call(this, currentItem) : 'L·ªói: Kh√¥ng th·ªÉ render c√¢u h·ªèi.'}
                        </div>
                        <div id="feedback-container" class="mt-6 min-h-[68px]"></div>
                        <div class="report-actions">
                            <button class="report-btn" data-report-type="error"><i class="fas fa-bug mr-2"></i>B√°o l·ªói</button>
                            <button class="report-btn" data-report-type="explanation"><i class="fas fa-question-circle mr-2"></i>C·∫ßn gi·∫£i th√≠ch</button>
                        </div>
                    </div>
                `;

                document.getElementById('exit-practice-btn').addEventListener('click', async () => {
                    await this.updateFirestoreProgress();
                    this.renderDashboard();
                    this.renderHeader(false);
                });

                this.DOM.main.querySelector('.report-actions').addEventListener('click', e => {
                    const button = e.target.closest('button');
                    if (button && button.dataset.reportType) {
                        this.handleReportSubmission(button.dataset.reportType);
                    }
                });
                this.attachPracticeEventListeners(currentItem, document.getElementById('question-container'));
            },

            async renderTestSummary() {
                const { level, score, items } = this.state.currentPractice;
                const total = items.length;
                const accuracy = total > 0 ? (score / total) : 0;
                const testConfig = this.CONFIG.RULES.PROFICIENCY_TESTS[level];
                const didPass = accuracy >= testConfig.passMark;
                let title = didPass ? "üéâ Ch√∫c m·ª´ng, b·∫°n ƒë√£ qua!" : "C·∫ßn c·ªë g·∫Øng h∆°n!";
                let message = `B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng ${score} / ${total} c√¢u, ƒë·∫°t <strong>${(accuracy * 100).toFixed(1)}%</strong>. T·ªâ l·ªá y√™u c·∫ßu l√† ${(testConfig.passMark * 100)}%.`;
                const levelProgress = this.state.userProgress.levels[level];

                if (didPass) {
                    message += `<br>Level ${level} ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† ho√†n th√†nh. To√†n b·ªô ki·∫øn th·ª©c c·ªßa level n√†y ƒë∆∞·ª£c t√≠nh l√† ƒë√£ h·ªçc.`;
                    levelProgress.status = 'passed';
                    
                    const tasksForLevel = this.getAllTasksForLevel(level);
                    tasksForLevel.forEach(task => levelProgress.completedTasks.add(task.taskUID));

                    const nextLevel = level + 1;
                    if (this.CONFIG.LEVELS[nextLevel]) {
                        this.state.userProgress.levels[nextLevel].status = 'unlocked';
                    }
                } else {
                    const attemptsLeft = testConfig.maxAttempts - levelProgress.testAttempts;
                    message += `<br>B·∫°n c√≤n <strong>${attemptsLeft}</strong> l·∫ßn th·ª≠ l·∫°i. H√£y luy·ªán t·∫≠p th√™m nh√©.`;
                }

                await this.updateFirestoreProgress();
                this.showModal(title, message, false, () => {
                    this.renderDashboard();
                    this.renderHeader(false);
                }, null, "V·ªÅ B·∫£ng ƒëi·ªÅu khi·ªÉn");
            },

            async renderFinalTestSummary() {
                const { score, items } = this.state.currentPractice;
                const total = items.length;
                const accuracy = total > 0 ? (score / total * 100) : 0;

                let title = "Ho√†n th√†nh b√†i ki·ªÉm tra cu·ªëi k·ª≥!";
                let message = `Ch√∫c m·ª´ng b·∫°n ƒë√£ ho√†n th√†nh b√†i ki·ªÉm tra cu·ªëi c√πng! <br>K·∫øt qu·∫£ c·ªßa b·∫°n l√†: <strong>${score} / ${total} c√¢u ƒë√∫ng (${accuracy.toFixed(1)}%)</strong>.`;

                this.state.userProgress.finalTestTaken = true;
                this.state.userProgress.finalTestScore = accuracy.toFixed(1);

                await this.updateFirestoreProgress();
                this.showModal(title, message, false, () => {
                    this.renderDashboard();
                    this.renderHeader(false);
                }, null, "V·ªÅ B·∫£ng ƒëi·ªÅu khi·ªÉn");
            },

            async renderSessionSummary() {
                const { level, sessionCorrectUIDs, sessionIncorrectUIDs } = this.state.currentPractice;
                const correctCount = sessionCorrectUIDs.size;
                const incorrectCount = sessionIncorrectUIDs.size;

                const message = `
                    <div class="text-left">
                        <p class="mb-4">B·∫°n v·ª´a ho√†n th√†nh m·ªôt phi√™n luy·ªán t·∫≠p. D∆∞·ªõi ƒë√¢y l√† k·∫øt qu·∫£:</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="bg-bg-dark p-4 rounded-lg border border-glass-border">
                                <h3 class="font-bold text-green-400 mb-2">ƒê√£ tr·∫£ l·ªùi ƒë√∫ng (${correctCount})</h3>
                                <p class="text-sm text-text-secondary">Tuy·ªát v·ªùi! Nh·ªØng ki·∫øn th·ª©c n√†y ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n v√†o ti·∫øn tr√¨nh c·ªßa b·∫°n.</p>
                            </div>
                            <div class="bg-bg-dark p-4 rounded-lg border border-glass-border">
                                <h3 class="font-bold text-red-400 mb-2">C·∫ßn xem l·∫°i (${incorrectCount})</h3>
                                <p class="text-sm text-text-secondary">ƒê·ª´ng lo, h·ªá th·ªëng s·∫Ω ∆∞u ti√™n nh·ªØng d·∫°ng b√†i n√†y trong c√°c phi√™n h·ªçc t·ªõi.</p>
                            </div>
                        </div>
                    </div>
                `;
                await this.updateFirestoreProgress();
                this.showModal(`T·ªïng k·∫øt phi√™n h·ªçc Level ${level}`, message, true, () => this.startPractice(level), () => {
                    this.renderDashboard();
                    this.renderHeader(false);
                }, "Luy·ªán t·∫≠p ti·∫øp", "V·ªÅ Dashboard");
            },
            
            // --- HTML Generation for Questions ---
            getMeaningMCQHTML(item) {
                const tasks = item.generated_tasks.meaning_mcq;
                if (!tasks || !tasks.distractors_vi) return '<div>Kh√¥ng c√≥ ƒë·ªß d·ªØ li·ªáu cho d·∫°ng b√†i t·∫≠p n√†y.</div>';
                const correctAnswer = item.meaning;
                const distractors = this.shuffleArray([...tasks.distractors_vi]).slice(0, 3);
                this.state.currentPractice.correctAnswer = correctAnswer;
                const options = this.shuffleArray([correctAnswer, ...distractors]);
                const info = this.EXERCISE_INFO.MeaningMCQ;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><div class="min-h-[60px] mb-8 font-poppins font-bold text-4xl text-center">${item.word}</div><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getWordFamilyMCQHTML(item) {
                const tasks = item.generated_tasks.word_family_mcq;
                if (!tasks || !tasks.sentence) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_answer;
                const sentence = tasks.sentence.replace(tasks.blank_placeholder, '<span class="font-bold text-primary-accent">[...]</span>');
                const options = this.shuffleArray([tasks.correct_answer, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.WordFamilyMCQ;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-xl font-serif italic text-text-secondary min-h-[60px] mb-8">"${sentence}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getSentenceUnscrambleHTML(item) {
                const tasks = item.generated_tasks.sentence_unscramble;
                if (!tasks || !tasks.correct_sentence) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_sentence;
                const words = this.shuffleArray(tasks.correct_sentence.split(' '));
                const info = this.EXERCISE_INFO.SentenceUnscramble;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">Click v√†o c√°c t·ª´ theo ƒë√∫ng th·ª© t·ª± ƒë·ªÉ t·∫°o th√†nh c√¢u ho√†n ch·ªânh.</p><div id="unscramble-answer-area" class="min-h-[60px] p-4 border-2 border-dashed border-gray-600 rounded-lg mb-4 flex flex-wrap gap-2"></div><div id="unscramble-source-area" class="flex flex-wrap gap-2">${words.map(word => `<button class="px-4 py-2 bg-purple-600 hover:bg-purple-500 transition-colors rounded-lg">${word}</button>`).join('')}</div><div class="mt-6 text-right"><button id="check-btn" class="cta-btn">Ki·ªÉm tra</button></div></div>`;
            },
            getErrorCorrectionHTML(item) {
                const tasks = item.generated_tasks.error_correction;
                if (!tasks || !tasks.incorrect_sentence) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_sentence;
                const info = this.EXERCISE_INFO.ErrorCorrection;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">Vi·∫øt l·∫°i c√¢u sau cho ƒë√∫ng.</p><p class="text-xl font-serif italic text-text-secondary min-h-[60px] mb-8">"${tasks.incorrect_sentence}"</p><div class="flex gap-2"><input type="text" id="text-input" class="text-input-styled w-full text-lg" placeholder="Nh·∫≠p c√¢u ƒë√∫ng t·∫°i ƒë√¢y..."><button id="check-btn" class="cta-btn !py-3">Ki·ªÉm tra</button></div></div>`;
            },
            getIPAFillHTML(item) {
                const tasks = item.generated_tasks.ipa_fill;
                if (!tasks || !tasks.gapped_ipa) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_vowel;
                const options = this.shuffleArray([tasks.correct_vowel, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.IPAFill;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">Ch·ªçn √¢m ƒë√∫ng ƒë·ªÉ ho√†n th√†nh phi√™n √¢m cho t·ª´ <strong class="text-primary-accent">"${item.word}"</strong></p><p class="text-3xl font-mono text-center min-h-[60px] mb-8">/${tasks.gapped_ipa}/</p><div id="answer-options" class="grid grid-cols-2 sm:grid-cols-4 gap-3">${options.map(opt => `<button class="answer-option font-mono text-center !text-2xl" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getBestFitReplacementHTML(item) {
                const tasks = item.generated_tasks.best_fit_replacement;
                if (!tasks || !tasks.sentence) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_answer;
                const sentence = tasks.sentence.replace(tasks.word_to_replace, `<span class="font-bold text-primary-accent"><u>${tasks.word_to_replace}</u></span>`);
                const options = this.shuffleArray([tasks.correct_answer, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.BestFitReplacement;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-xl font-serif italic text-text-secondary min-h-[60px] mb-8">"${sentence}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getInferenceFromScenarioHTML(item) {
                const tasks = item.generated_tasks.inference_from_scenario;
                if (!tasks || !tasks.scenario) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_answer;
                const options = this.shuffleArray([tasks.correct_answer, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.InferenceFromScenario;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-md font-serif italic text-text-secondary mb-4">"${tasks.scenario}"</p><p class="text-lg font-semibold text-text-light mb-6">${tasks.question}</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getBestParaphraseHTML(item) {
                const tasks = item.generated_tasks.best_paraphrase;
                if (!tasks || !tasks.options) return this.getMeaningMCQHTML(item);
                const correctOption = tasks.options.find(opt => opt.is_correct);
                this.state.currentPractice.correctAnswer = correctOption.text;
                const options = this.shuffleArray(tasks.options.map(opt => opt.text));
                const info = this.EXERCISE_INFO.BestParaphrase;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">C√¢u g·ªëc:</p><p class="text-xl font-serif italic text-text-secondary min-h-[60px] mb-8">"${tasks.original_sentence}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getAudioListeningHTML(item) {
                this.state.currentPractice.correctAnswer = item.word;
                const info = this.EXERCISE_INFO.AudioListening;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><div class="text-center mb-6"><button id="play-audio-btn" data-audio-url="${item.audioUrl}" class="text-6xl text-primary-accent hover:text-violet-400 transition-colors"><i class="fas fa-play-circle"></i></button></div><div class="flex gap-2"><input type="text" id="text-input" class="text-input-styled w-full text-lg" placeholder="Nh·∫≠p t·ª´ b·∫°n nghe ƒë∆∞·ª£c..."><button id="check-btn" class="cta-btn !py-3">Ki·ªÉm tra</button></div></div>`;
            },
            getTripledSentenceHTML(item) {
                const tasks = item.generated_tasks.tripled_sentence;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.keyword;
                const sentencesHTML = tasks.examples.map(sentence => `<p class="text-lg font-serif italic text-text-secondary mb-2">"${sentence.replace(new RegExp(`\\b${tasks.keyword}\\b`, 'gi'), '[...]')}"</p>`).join('');
                const info = this.EXERCISE_INFO.TripledSentence;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">C√πng m·ªôt t·ª´ c√≤n thi·∫øu trong c·∫£ ba c√¢u sau.</p><div class="space-y-3 mb-6">${sentencesHTML}</div><div class="flex gap-2"><input type="text" id="text-input" class="text-input-styled w-full text-lg" placeholder="Nh·∫≠p t·ª´ c√≤n thi·∫øu..."><button id="check-btn" class="cta-btn !py-3">Ki·ªÉm tra</button></div></div>`;
            },
            getAntonymMCQHTML(item) {
                const tasks = item.generated_tasks.antonym_mcq;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_antonym;
                const options = this.shuffleArray([tasks.correct_antonym, ...tasks.distractors]);
                const sentence = tasks.sentence_context.replace(tasks.keyword, `<strong class="text-primary-accent">${tasks.keyword}</strong>`);
                const info = this.EXERCISE_INFO.AntonymMCQ;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">ƒê√¢u l√† t·ª´ tr√°i nghƒ©a v·ªõi t·ª´ ƒë∆∞·ª£c in ƒë·∫≠m?</p><p class="text-xl font-serif italic text-text-secondary min-h-[60px] mb-8">"${sentence}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getMainIdeaHTML(item) {
                const tasks = item.generated_tasks.main_idea;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_answer;
                const options = this.shuffleArray([tasks.correct_answer, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.MainIdea;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">ƒê·ªçc ƒëo·∫°n vƒÉn v√† ch·ªçn √Ω ch√≠nh.</p><p class="text-md font-serif italic text-text-secondary mb-6 p-4 border border-glass-border rounded-lg bg-black/10">"${tasks.paragraph}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getParagraphCompletionHTML(item) {
                const tasks = item.generated_tasks.paragraph_completion;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_conclusion;
                const options = this.shuffleArray([tasks.correct_conclusion, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.ParagraphCompletion;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">C√¢u n√†o sau ƒë√¢y k·∫øt th√∫c ƒëo·∫°n vƒÉn h·ª£p l√Ω nh·∫•t?</p><p class="text-md font-serif italic text-text-secondary mb-6 p-4 border border-glass-border rounded-lg bg-black/10">"${tasks.paragraph_body}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getArgumentStrengtheningHTML(item) {
                const tasks = item.generated_tasks.argument_strengthening;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_evidence;
                const options = this.shuffleArray([tasks.correct_evidence, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.ArgumentStrengthening;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">Lu·∫≠n ƒëi·ªÉm n√†o c·ªßng c·ªë cho l·∫≠p lu·∫≠n sau?</p><p class="text-md font-serif italic text-text-secondary mb-6 p-4 border border-glass-border rounded-lg bg-black/10">"${tasks.argument_text}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getArgumentWeakeningHTML(item) {
                const tasks = item.generated_tasks.argument_weakening;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_weakener;
                const options = this.shuffleArray([tasks.correct_weakener, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.ArgumentWeakening;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">Lu·∫≠n ƒëi·ªÉm n√†o l√†m suy y·∫øu l·∫≠p lu·∫≠n sau?</p><p class="text-md font-serif italic text-text-secondary mb-6 p-4 border border-glass-border rounded-lg bg-black/10">"${tasks.argument_text}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getTonePurposeAnalysisHTML(item) {
                const tasks = item.generated_tasks.tone_purpose_analysis;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_answer;
                const options = this.shuffleArray([tasks.correct_answer, ...tasks.distractors]);
                const info = this.EXERCISE_INFO.TonePurposeAnalysis;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">${tasks.question}</p><p class="text-md font-serif italic text-text-secondary mb-6 p-4 border border-glass-border rounded-lg bg-black/10">"${tasks.paragraph}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },
            getSentenceRoleAnalysisHTML(item) {
                const tasks = item.generated_tasks.sentence_role_analysis;
                if (!tasks) return this.getMeaningMCQHTML(item);
                this.state.currentPractice.correctAnswer = tasks.correct_role;
                const options = this.shuffleArray([tasks.correct_role, ...tasks.distractors]);
                const paragraphHTML = tasks.paragraph.replace(`[${tasks.highlighted_sentence_index + 1}]`, `<strong class="text-primary-accent">[${tasks.highlighted_sentence_index + 1}]</strong>`);
                const info = this.EXERCISE_INFO.SentenceRoleAnalysis;
                return `<div class="question-block"><h2 class="text-xl font-bold font-poppins text-text-light mb-4">${info.icon} ${info.name}</h2><p class="text-text-secondary mb-4">Vai tr√≤ c·ªßa c√¢u ƒë∆∞·ª£c in ƒë·∫≠m l√† g√¨?</p><p class="text-md font-serif italic text-text-secondary mb-6 p-4 border border-glass-border rounded-lg bg-black/10">"${paragraphHTML}"</p><div id="answer-options" class="space-y-3">${options.map(opt => `<button class="answer-option" data-answer="${opt}">${opt}</button>`).join('')}</div></div>`;
            },

            attachPracticeEventListeners(item, container, isGuide = false) {
                if (!container) return;
                const checkAnswerFunction = isGuide ? this.checkGuideAnswer.bind(this) : this.checkAnswer.bind(this);
                switch(item.exerciseType) {
                    case 'MeaningMCQ': case 'WordFamilyMCQ': case 'IPAFill': case 'BestFitReplacement': case 'InferenceFromScenario': case 'BestParaphrase': case 'AntonymMCQ': case 'MainIdea': case 'ParagraphCompletion': case 'ArgumentStrengthening': case 'ArgumentWeakening': case 'TonePurposeAnalysis': case 'SentenceRoleAnalysis':
                        container.querySelectorAll('.answer-option').forEach(option => { option.addEventListener('click', (e) => checkAnswerFunction(e.currentTarget.dataset.answer, item, container, e.currentTarget)); }); break;
                    case 'AudioListening': case 'ErrorCorrection': case 'TripledSentence':
                        const input = container.querySelector('#text-input'); const checkBtn = container.querySelector('#check-btn');
                        container.querySelector('#play-audio-btn')?.addEventListener('click', (e) => { this.playAudio(e.currentTarget.dataset.audioUrl); });
                        if (input && checkBtn) { const doCheck = () => checkAnswerFunction(input.value, item, container, input); checkBtn.addEventListener('click', doCheck); input.addEventListener('keypress', (e) => { if (e.key === 'Enter') doCheck(); }); }
                        break;
                    case 'SentenceUnscramble': {
                        const answerArea = container.querySelector('#unscramble-answer-area'); const sourceArea = container.querySelector('#unscramble-source-area');
                        const moveToken = (e) => { if (e.target.tagName === 'BUTTON') { const isFromSource = e.currentTarget.id === 'unscramble-source-area'; (isFromSource ? answerArea : sourceArea).appendChild(e.target); } };
                        sourceArea.addEventListener('click', moveToken); answerArea.addEventListener('click', moveToken);
                        container.querySelector('#check-btn')?.addEventListener('click', () => { const answer = Array.from(answerArea.querySelectorAll('button')).map(t => t.textContent).join(' '); checkAnswerFunction(answer, item, container, answerArea); });
                        break;
                    }
                }
            },

            checkAnswer(userAnswer, item, container, selectedElement) {
                const correctAnswer = this.state.currentPractice.correctAnswer;
                const isCorrect = userAnswer.trim().toLowerCase() === correctAnswer.trim().toLowerCase();
                
                container.querySelectorAll('button, input').forEach(el => el.disabled = true);
                
                const levelProgress = this.state.currentPractice.level !== "Final" && this.state.userProgress.levels[this.state.currentPractice.level];
                
                if (isCorrect) {
                    this.state.currentPractice.sessionCorrectUIDs.add(item.taskUID);
                    if(this.state.currentPractice.isTest) {
                        this.state.currentPractice.score++;
                    } else {
                        if (levelProgress && !levelProgress.completedTasks.has(item.taskUID)) {
                            levelProgress.completedTasks.add(item.taskUID);
                        }
                    }
                } else {
                    this.state.currentPractice.sessionIncorrectUIDs.add(item.taskUID);
                }
                
                this.showFeedback(isCorrect, correctAnswer, container, selectedElement);
                
                if (isCorrect && !this.state.currentPractice.isTest) {
                    this.checkLevelUp(this.state.currentPractice.level);
                }
            },

            checkGuideAnswer(userAnswer, item, container, selectedElement) {
                const correctAnswer = this.state.currentPractice.correctAnswer;
                const isCorrect = userAnswer.trim().toLowerCase() === correctAnswer.trim().toLowerCase();
                container.querySelectorAll('button, input').forEach(el => el.disabled = true);
                this.showFeedback(isCorrect, correctAnswer, container.parentElement.querySelector('#guide-feedback-container'), selectedElement, true);
            },

            showFeedback(isCorrect, correctAnswer, questionContainer, selectedElement, isGuide = false) {
                const feedbackContainer = document.getElementById(isGuide ? 'guide-feedback-container' : 'feedback-container');
                if (!feedbackContainer) return;

                // Highlight selected MCQ option
                if(selectedElement && selectedElement.classList.contains('answer-option')) {
                    selectedElement.classList.add('selected', isCorrect ? 'correct' : 'incorrect');
                }
                
                // Highlight correct MCQ option if answer was wrong
                if (!isCorrect) {
                    const options = questionContainer.querySelectorAll('.answer-option');
                    options.forEach(opt => {
                        if (opt.dataset.answer.trim().toLowerCase() === correctAnswer.trim().toLowerCase()) {
                            opt.classList.add('correct-answer');
                        }
                    });
                }

                const bgColor = isCorrect ? 'bg-green-500/20' : 'bg-red-500/20';
                const textColor = isCorrect ? 'text-green-300' : 'text-red-300';
                let message = isCorrect ? 'Ch√≠nh x√°c!' : `Sai r·ªìi! ƒê√°p √°n ƒë√∫ng l√†: <strong class="font-bold text-white">${correctAnswer}</strong>`;
                
                const nextButtonHTML = isGuide ? '' : `<button id="next-question-btn" class="cta-btn secondary !py-2 !px-4">Ti·∫øp t·ª•c <i class="fas fa-arrow-right ml-2"></i></button>`;

                feedbackContainer.innerHTML = `
                    <div class="${bgColor} ${textColor} p-4 rounded-lg flex justify-between items-center fade-in">
                        <p class="font-semibold">${message}</p>
                        ${nextButtonHTML}
                    </div>`;
                
                if (!isGuide) {
                    const nextBtn = document.getElementById('next-question-btn');
                    nextBtn.focus();
                    nextBtn.addEventListener('click', () => {
                        this.state.currentPractice.index++;
                        this.renderPracticeView();
                    });
                }
            },
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; }
                return array;
            },

            showModal(title, message, showCancel = false, onConfirm = null, onCancel = null, confirmText = 'X√°c nh·∫≠n', cancelText = 'H·ªßy', modalClass = 'max-w-md') {
                const modalId = 'main-modal';
                const existingModal = document.getElementById(modalId);
                if (existingModal) existingModal.remove();
                
                const modalContainer = document.createElement('div');
                modalContainer.id = modalId;
                modalContainer.className = "fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4";
                
                const buttonsHTML = showCancel 
                    ? `<button id="modal-cancel-btn" class="cta-btn secondary">${cancelText}</button><button id="modal-confirm-btn" class="cta-btn">${confirmText}</button>` 
                    : `<button id="modal-confirm-btn" class="cta-btn w-full">${confirmText}</button>`;
                
                modalContainer.innerHTML = `
                    <div class="glass-panel p-6 sm:p-8 w-full ${modalClass} fade-in max-h-[90vh] overflow-y-auto">
                        <h3 class="text-xl font-bold font-poppins mb-4 text-left">${title}</h3>
                        <div class="text-text-secondary mb-6">${message}</div>
                        <div class="flex gap-4 justify-end mt-8">${buttonsHTML}</div>
                    </div>`;
                
                this.DOM.modal.appendChild(modalContainer);
                
                const confirmBtn = modalContainer.querySelector('#modal-confirm-btn');
                const cancelBtn = modalContainer.querySelector('#modal-cancel-btn');
                
                const closeModal = () => modalContainer.remove();
                
                confirmBtn.onclick = () => {
                    if (onConfirm) onConfirm();
                    closeModal();
                };
                
                if (cancelBtn) {
                    cancelBtn.onclick = () => {
                        if (onCancel) onCancel();
                        closeModal();
                    };
                }
            },

            startFlashcardSession(type) {
                if (type === 'structure') {
                    this.showModal("T√≠nh nƒÉng s·∫Øp ra m·∫Øt", "H·ªçc flashcard cho c·∫•u tr√∫c c√¢u hi·ªán ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn. Vui l√≤ng quay l·∫°i sau.");
                    return;
                }
                this.renderHeader(true);
                this.state.currentFlashcard.items = this.shuffleArray([...this.state.wordList]);
                if (this.state.currentFlashcard.items.length === 0) {
                    this.showModal("Th√¥ng b√°o", "Kh√¥ng c√≥ t·ª´ v·ª±ng ƒë·ªÉ h·ªçc b·∫±ng flashcard.");
                    return;
                }
                this.state.currentFlashcard.index = 0;
                this.renderFlashcardViewer();
            },

            renderFlashcardViewer() {
                this.DOM.main.innerHTML = `
                    <div class="glass-panel p-4 sm:p-6 fade-in">
                        <div style="height: 70vh; max-width: 800px; margin: 0 auto; display: flex; flex-direction: column;">
                            <div class="flex justify-end items-center mb-4">
                                <div id="card-counter" class="font-semibold text-text-secondary"></div>
                            </div>
                            <div style="flex-grow: 1; display: flex; align-items: center; justify-content: center;">
                                <div class="flashcard" id="flashcard" style="width: 100%; height: 100%; max-height: 400px; cursor: pointer;">
                                    <div class="flashcard-inner">
                                        <div class="flashcard-face flashcard-front"></div>
                                        <div class="flashcard-face flashcard-back"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="flex justify-between items-center p-4">
                                <button id="prev-card-btn" class="cta-btn secondary !rounded-full !w-14 !h-14 text-xl"><i class="fas fa-arrow-left"></i></button>
                                <p class="text-sm text-text-secondary hidden sm:block">B·∫•m v√†o th·∫ª ƒë·ªÉ l·∫≠t</p>
                                <button id="next-card-btn" class="cta-btn secondary !rounded-full !w-14 !h-14 text-xl"><i class="fas fa-arrow-right"></i></button>
                            </div>
                        </div>
                    </div>`;
                this.updateFlashcardView();
                document.getElementById('prev-card-btn').addEventListener('click', () => this.navigateCard(-1));
                document.getElementById('next-card-btn').addEventListener('click', () => this.navigateCard(1));
                document.getElementById('flashcard').addEventListener('click', e => { if (!e.target.closest('.audio-btn')) e.currentTarget.classList.toggle('is-flipped'); });
            },

            updateFlashcardView() {
                const { items, index } = this.state.currentFlashcard;
                const item = items[index];
                const card = document.getElementById('flashcard');
                if (!item || !card) return;

                card.classList.remove('is-flipped');
                
                setTimeout(() => {
                    const front = card.querySelector('.flashcard-front');
                    const back = card.querySelector('.flashcard-back');

                    const audioBtnHTML = item.audioUrl ? `<button class="audio-btn" data-audio-url="${item.audioUrl}"><i class="fas fa-volume-up"></i></button>` : '';
                    front.innerHTML = `${audioBtnHTML}<div class="flashcard-word">${item.word}</div>`;
                    back.innerHTML = `${audioBtnHTML}<div class="flashcard-meaning">${item.meaning}</div><p class="flashcard-pronunciation">${item.pronunciation || ''} <span class="mx-2">&bull;</span> ${item.type || ''}</p><p class="flashcard-example">"${item.generated_tasks?.basic_example || ''}"</p>`;
                    
                    card.querySelectorAll('.audio-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.playAudio(e.currentTarget.dataset.audioUrl);
                        });
                    });
                }, 150);
                
                document.getElementById('card-counter').textContent = `${index + 1} / ${items.length}`;
            },

            navigateCard(direction) {
                const { items } = this.state.currentFlashcard;
                const newIndex = this.state.currentFlashcard.index + direction;
                this.state.currentFlashcard.index = (newIndex + items.length) % items.length;
                this.updateFlashcardView();
            },

            playAudio(url) {
                if (!url) return;
                const audio = new Audio(url);
                audio.play().catch(e => console.error("Audio play failed:", e));
            },

            async handleReportSubmission(reportType) {
                const item = this.state.currentPractice.items[this.state.currentPractice.index];
                if (!item) return;

                const result = await this.showReportModal(reportType);
                if (!result.confirmed) return;

                const issueId = `${this.state.testData.id}_${item.id}_${item.exerciseType}`;
                const issueRef = doc(this.db, "test_issues", issueId);
                
                const questionContainer = this.DOM.main.querySelector('#question-container');
                const renderedQuestionHTML = questionContainer ? questionContainer.innerHTML : '<em>Kh√¥ng th·ªÉ t·∫£i n·ªôi dung c√¢u h·ªèi.</em>';

                try {
                    await runTransaction(this.db, async (transaction) => {
                        const issueDoc = await transaction.get(issueRef);
                        const reporterInfo = {
                            studentId: this.state.studentId, studentName: this.state.studentName,
                            comment: result.comment, category: result.category, 
                            reportedAt: new Date()
                        };

                        if (!issueDoc.exists()) {
                            const newIssueData = {
                                testId: this.state.testData.id, testTitle: this.state.testData.title,
                                itemId: item.id, itemWord: item.word, questionType: item.exerciseType,
                                questionData: item, renderedQuestionHTML: renderedQuestionHTML,
                                status: 'open', lastReportedAt: serverTimestamp(),
                                reports: [reporterInfo]
                            };
                            transaction.set(issueRef, newIssueData);
                        } else {
                            transaction.update(issueRef, {
                                reports: arrayUnion(reporterInfo),
                                lastReportedAt: serverTimestamp(),
                                status: 'open'
                            });
                        }
                    });
                    this.showModal("Th√†nh c√¥ng", "B√°o c√°o c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn gi√°o vi√™n.");
                } catch (error) {
                    console.error("L·ªói khi g·ª≠i b√°o c√°o:", error);
                    this.showModal("L·ªói", "Kh√¥ng th·ªÉ g·ª≠i b√°o c√°o. Vui l√≤ng th·ª≠ l·∫°i.");
                }
            },

            showReportModal(reportType) {
                return new Promise(resolve => {
                    const isError = reportType === 'error'; 
                    const title = isError ? 'B√°o c√°o l·ªói ƒë·ªÅ' : 'Y√™u c·∫ßu gi·∫£i th√≠ch';
                    let contentHTML = isError 
                        ? `<p class="text-text-secondary mb-4">Vui l√≤ng ch·ªçn lo·∫°i l·ªói b·∫°n g·∫∑p ph·∫£i:</p><div class="report-category-group space-y-2"><div><input type="radio" name="error-category" value="L·ªói ch√≠nh t·∫£" id="cat-typo" checked><label for="cat-typo">L·ªói ch√≠nh t·∫£</label></div><div><input type="radio" name="error-category" value="ƒê√°p √°n ƒë√∫ng b·ªã sai" id="cat-wrong-answer"><label for="cat-wrong-answer">ƒê√°p √°n ƒë√∫ng b·ªã sai</label></div><div><input type="radio" name="error-category" value="C√¢u h·ªèi kh√¥ng r√µ r√†ng" id="cat-unclear"><label for="cat-unclear">C√¢u h·ªèi kh√¥ng r√µ r√†ng</label></div><div><input type="radio" name="error-category" value="L·ªói k·ªπ thu·∫≠t" id="cat-tech"><label for="cat-tech">L·ªói k·ªπ thu·∫≠t</label></div></div>` 
                        : `<p class="text-text-secondary mb-4">Ghi ch√∫ c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c g·ª≠i t·ªõi gi√°o vi√™n ƒë·ªÉ ƒë∆∞·ª£c gi·∫£i ƒë√°p.</p>`;
                    contentHTML += `<textarea id="report-comment-input" placeholder="Th√™m ghi ch√∫ (kh√¥ng b·∫Øt bu·ªôc)..." rows="3"></textarea>`;
                    
                    this.showModal(
                        title, 
                        contentHTML, 
                        true, 
                        () => {
                            const modal = document.getElementById('main-modal');
                            const selectedCategory = isError ? (modal.querySelector('input[name="error-category"]:checked')?.value || 'Kh√°c') : 'Y√™u c·∫ßu gi·∫£i th√≠ch';
                            const comment = modal.querySelector('#report-comment-input').value;
                            resolve({ confirmed: true, category: selectedCategory, comment: comment });
                        },
                        () => resolve({ confirmed: false }),
                        "G·ª≠i",
                        "H·ªßy"
                    );
                });
            },
            
            renderGuideModal() {
                const rules = this.CONFIG.RULES;
                let message = `
                    <div class="space-y-8 text-left">
                        <div class="guide-section">
                            <h3><i class="fas fa-scroll mr-3"></i>Quy T·∫Øc Chung</h3>
                            <div class="space-y-4">
                                <div class="guide-rule">
                                    <h4 class="font-bold text-lg text-light">M·ªü Kh√≥a Level</h4>
                                    <p class="text-text-secondary">Ho√†n th√†nh <strong class="text-white">${rules.UNLOCK_THRESHOLD * 100}%</strong> s·ªë b√†i t·∫≠p c·ªßa m·ªôt level ƒë·ªÉ t·ª± ƒë·ªông m·ªü kh√≥a level ti·∫øp theo.</p>
                                </div>
                                <div class="guide-rule">
                                    <h4 class="font-bold text-lg text-light">Ki·ªÉm Tra V∆∞·ª£t C·∫•p</h4>
                                    <p class="text-text-secondary">Y√™u c·∫ßu ƒë·ªÉ qua l√† <strong class="text-white">${rules.PROFICIENCY_TESTS[1].passMark * 100}%</strong>. B·∫°n c√≥ t·ªëi ƒëa <strong class="text-white">${rules.PROFICIENCY_TESTS[1].maxAttempts}</strong> l·∫ßn th·ª≠ cho m·ªói level.</p>
                                    <ul class="list-disc list-inside text-text-secondary mt-2 space-y-1">
                                        <li><strong class="text-white">Level 1:</strong> Lu√¥n c√≥ s·∫µn.</li>
                                        <li><strong class="text-white">Level 2:</strong> M·ªü kh√≥a khi ho√†n th√†nh <strong class="text-white">${rules.PROFICIENCY_TEST_UNLOCK[2] * 100}%</strong> b√†i t·∫≠p Level 2.</li>
                                        <li><strong class="text-white">Level 3:</strong> M·ªü kh√≥a khi ho√†n th√†nh <strong class="text-white">${rules.PROFICIENCY_TEST_UNLOCK[3] * 100}%</strong> b√†i t·∫≠p Level 3.</li>
                                    </ul>
                                </div>
                                <div class="guide-rule">
                                    <h4 class="font-bold text-lg text-light">B√†i Ki·ªÉm Tra Cu·ªëi K·ª≥</h4>
                                    <p class="text-text-secondary">M·ªü kh√≥a khi ti·∫øn ƒë·ªô t·ªïng qu√°t ƒë·∫°t <strong class="text-white">${rules.FINAL_TEST_UNLOCK_THRESHOLD * 100}%</strong>.</p>
                                </div>
                            </div>
                        </div>
                        ${Object.keys(this.CONFIG.LEVELS).map(levelKey => this.getGuideLevelSectionHTML(levelKey)).join('')}
                    </div>
                `;
                this.showModal("H∆∞·ªõng D·∫´n & Quy T·∫Øc", message, false, null, null, 'ƒê√£ hi·ªÉu', null, 'max-w-4xl');
                
                document.getElementById('main-modal').querySelectorAll('button[data-guide-type]').forEach(btn => {
                    btn.addEventListener('click', e => this.renderGuideExampleModal(e.currentTarget.dataset.guideType));
                });
            },

            getGuideLevelSectionHTML(levelKey) {
                const levelNum = parseInt(levelKey);
                const levelConfig = this.CONFIG.LEVELS[levelNum];
                
                return `
                <div class="guide-section mt-8">
                    <h3><i class="fas fa-layer-group mr-3"></i>Level ${levelNum}: ${levelConfig.name}</h3>
                    <p class="text-text-secondary mb-6">C√°c d·∫°ng b√†i t·∫≠p c√≥ trong level n√†y:</p>
                    <div class="flex flex-wrap gap-3">
                        ${levelConfig.tasks.map(taskType => {
                            const info = this.EXERCISE_INFO[taskType];
                            return `<button data-guide-type="${taskType}" class="cta-btn secondary !rounded-lg !text-sm !py-2 !px-4">${info.icon} ${info.name}</button>`;
                        }).join('')}
                    </div>
                </div>
                `;
            },

            renderGuideExampleModal(exerciseType) {
                const info = this.EXERCISE_INFO[exerciseType];
                const suitableItem = this.state.wordList.find(item => this.isTaskAvailable(item, exerciseType));

                if (!suitableItem) {
                    this.showModal("Kh√¥ng c√≥ d·ªØ li·ªáu", `Hi·ªán t·∫°i ch∆∞a c√≥ d·ªØ li·ªáu ph√π h·ª£p ƒë·ªÉ t·∫°o v√≠ d·ª• cho d·∫°ng b√†i: "${info.name}".`);
                    return;
                }
                
                suitableItem.exerciseType = exerciseType;
                const renderFunction = this[`get${exerciseType}HTML`];
                if (typeof renderFunction !== 'function') return;
                
                const exampleHTML = renderFunction.call(this, suitableItem, true);

                this.showModal(
                    `H∆∞·ªõng d·∫´n: ${info.name}`,
                    `<p class="text-text-secondary mb-6 text-left">${info.desc}</p>
                    <div class="bg-bg-dark p-4 rounded-lg border border-glass-border">
                        <h4 class="font-bold mb-3 text-left">V√≠ d·ª• t∆∞∆°ng t√°c:</h4>
                        <div id="guide-question-container">${exampleHTML}</div>
                        <div id="guide-feedback-container" class="mt-4"></div>
                    </div>`,
                    false, null, null, 'ƒê√≥ng', null, 'max-w-2xl'
                );
                
                const guideContainer = document.getElementById('guide-question-container');
                this.attachPracticeEventListeners(suitableItem, guideContainer, true);
            },
            
             getAllTasksForLevel(level) {
                const tasksForLevel = this.CONFIG.LEVELS[level].tasks;
                const allLevelTasks = [];
                this.state.wordList.forEach(word => {
                    tasksForLevel.forEach(taskType => {
                        if (this.isTaskAvailable(word, taskType)) {
                            allLevelTasks.push({ ...word, exerciseType: taskType, taskUID: `${word.id}::${taskType}` });
                        }
                    });
                });
                return allLevelTasks;
            }
        };

        document.addEventListener('DOMContentLoaded', () => App.init());
    </script>
</body>
</html>
